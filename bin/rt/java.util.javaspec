package java.util;

/*@

fixpoint pair<t1, t2> update_fst<t1, t2>(t1 v, pair<t1, t2> s) {
    switch(s) {
        case pair(a, b): return pair(v, b);
    }
}

fixpoint pair<t1, t2> update_snd<t1, t2>(t2 v, pair<t1, t2> s) {
    switch(s) {
        case pair(a, b): return pair(a, v);
    }
}

fixpoint boolean distinct<t>(list<t> xs) {
    switch (xs) {
        case nil: return true;
        case cons(x, xs0): return !mem(x, xs0) && distinct(xs0);
    }
}

lemma_auto(distinct(xs)) void distinct_tail<t>(list<t> xs);
requires distinct(xs) == true;
ensures distinct(tail(xs)) == true;

lemma_auto(fst_list(xs)) void equal_length<t1, t2>(list<pair<t1, t2> > xs);
 requires true;
 ensures length(xs) == length(fst_list(xs)) && length(xs) == length(snd_list(xs));

predicate list(List l, list<Object> val);

predicate set(Set s, list<Object> val); // Must not be a precise predicate since the order of elements in different fractions may be different!

predicate map(Map m, list<pair<Object, Object> > val);

predicate list_wrapper(Object o, list<Object> vs) = list(^o, vs);

predicate set_wrapper(Object o, list<Object> vs) = set(^o, vs);

predicate iter(Iterator i, real frac, Object col, predicate(Object, list<Object>) q, list<Object> val, int index);

lemma void iter_dispose(Iterator iter);
 requires iter(iter, ?f, ?col, ?q, ?val, ?index);
 ensures [f]q(col, val);
  
lemma_auto(length(remove(x, xs))) void length_remove<t>(t x, list<t> xs);
 requires true;
 ensures length(xs) - 1 <= length(remove(x, xs)) && length(remove(x, xs)) <= length(xs);
 
fixpoint t2 in_map<t1, t2>(t1 key, list<pair<t1, t2> > map) {
    switch(map) {
    	case nil: return default_value<t2>;
        case cons(m, m0): return fst(m) == key ? snd(m) : in_map(key, m0);
    }
}

fixpoint boolean contains_key<t1, t2>(t1 key, list<pair<t1, t2> > map) {
    switch(map) {
    	case nil: return false;
        case cons(m, m0): return fst(m) == key ? true : contains_key(key, m0); 
    }
}

fixpoint list<pair<t1, t2> > update_value<t1, t2>(t1 key, t2 value, list<pair<t1, t2> > map) {
    switch(map) {
    	case nil: return nil;
        case cons(m, m0): return fst(m) == key ? cons(update_snd(value, m), m0) : cons(m, update_value(key, value, m0));
    }
}

fixpoint list<pair<t1, t2> > remove_pair<t1, t2>(t1 key, list<pair<t1, t2> > map) {
    switch(map) {
    	case nil: return nil;
        case cons(m, m0): return fst(m) == key ? m0 : cons(m, remove_pair(key, m0));
    }
}

fixpoint list<pair<t1, t2> > remove_pair_nth<t1, t2>(int n, list<pair<t1, t2> > xs) {
    switch(xs) {
        case nil: return nil;
        case cons(h, t): return n == 0 ? t : cons(h, remove_pair_nth(n - 1, t));
    }
}

fixpoint list<t1> fst_list<t1, t2>(list<pair<t1, t2> > s) {
    switch(s) {
        case nil: return nil;
        case cons(x, xs0): return cons(fst(x), fst_list(xs0));
    }
}

fixpoint list<t2> snd_list<t1, t2>(list<pair<t1, t2> > s) {
    switch(s) {
        case nil: return nil;
        case cons(x, xs0): return cons(snd(x), snd_list(xs0));
    }
}

fixpoint boolean subset<t>(list<t> l1, list<t> l2) {
    switch(l2) {
    	case nil: return true;
        case cons(m, m0): return mem(m, l1) == true ? subset(l1, m0) : false; 
    }
}

fixpoint boolean not_null(list<Object> xs) {
    switch (xs) {
        case nil: return true;
        case cons(x, xs0): return x != null && not_null(xs0);
    }
}
@*/

interface List {
  boolean add(Object element);
  //@ requires list(this, ?val);
  //@ ensures list(this, append(val, cons(element, nil))) &*& result;
  Object get(int index);
  //@ requires list(this, ?v) &*& index < length(v); 
  //@ ensures result == nth(index, v) &*& list(this, v);
  Iterator iterator();
  //@ requires [?f]list(this, ?val);
  //@ ensures result != null &*& iter(result, f, this, list_wrapper, val, 0);
  int size();
  //@ requires list(this, ?val);
  //@ ensures list(this, val) &*& 0 <= result &*& result == length(val);
  boolean remove(Object element);
  //@ requires list(this, ?v);
  //@ ensures mem(element, v) ?list(this, remove(element, v)):list(this,v);
}
interface Iterator{
  boolean hasNext();
  //@ requires iter(this, ?frac, ?col, ?q, ?val, ?index);
  //@ ensures iter(this, frac, col, q, val, index) &*& result == (index < length(val));
  Object next();
  //@ requires iter(this, ?frac, ?col, ?q, ?val, ?index) &*& index < length(val);
  //@ ensures iter(this, frac, col, q, val, index+1) &*& result == nth(index, val);
  void remove();
  //@ requires iter(this, 1, ?col, ?q, ?val, ?index) &*& index <= length(val);
  //@ ensures iter(this, 1, col, q, remove_nth(index-1, val), index-1);
}
public class ArrayList implements List{
  ArrayList();
  //@ requires emp;
  //@ ensures list(this, nil);
}

interface Set {
	Iterator iterator();
  	//@ requires [?f]set(this, ?val1);
  	/*@ ensures result != null &*& iter(result, f, this, set_wrapper, ?val2, 0) 
  		&*& subset(val1, val2) == true &*& subset(val2, val1) == true &*& distinct(val2) == true; @*/
}

public class HashSet implements Set{
  HashSet();
  //@ requires emp;
  //@ ensures set(this, nil);
}

public interface Map {
	
}

public class IdentityHashMap implements Map {
	IdentityHashMap();
	//@ requires emp;
	//@ ensures map(this, nil);
	
	public Object put(Object key, Object value);
	//@ requires map(this, ?vals);
	/*@ ensures result == in_map(key, vals) 
	    &*& contains_key(key, vals) == true ? map(this, update_value(key, value, vals)) : map(this, append(vals, cons(pair(key, value), nil))); @*/
	
	public Object get(Object key);
	//@ requires map(this, ?vals) &*& contains_key(key, vals) == true;
  	//@ ensures result == in_map(key, vals) &*& map(this, vals) &*& mem(key, fst_list(vals)) == true &*& mem(result, snd_list(vals)) == true;
  	
  	public boolean containsKey(Object key);
	//@ requires map(this, ?vals);
	/*@ ensures map(this, vals) &*& result == contains_key(key, vals) &*& (contains_key(key, vals) == true ? 
				mem(key, fst_list(vals)) == true : mem(key, fst_list(vals)) == false); @*/
	
	public Object remove(Object key);
	//@ requires map(this, ?vals);
	//@ ensures result == in_map(key, vals) &*& contains_key(key, vals) ? map(this, remove_pair(key, vals)) : map(this, vals); 	
}