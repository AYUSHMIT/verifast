package java.lang;


/*@

inductive unit = unit;

inductive pair<a, b> = pair(a, b);

fixpoint a fst<a, b>(pair<a, b> p) {
    switch (p) {
        case pair(x, y): return x;
    }
}

fixpoint b snd<a, b>(pair<a, b> p) {
    switch (p) {
        case pair(x, y): return y;
    }
}

fixpoint t default_value<t>();

inductive boxed_int = boxed_int(int);
fixpoint int unboxed_int(boxed_int i) { switch (i) { case boxed_int(value): return value; } }

inductive boxed_bool = boxed_bool(boolean);
fixpoint boolean unboxed_bool(boxed_bool b) { switch (b) { case boxed_bool(value): return value; } }

lemma_auto(x%y) void modulo_nonnegative(int x, int y);
  requires 0 <= x && 0 < y;
  ensures 0 <= x % y && x % y < y;

lemma_auto void modulo_div(int x, int y);
  requires y != 0;
  ensures y * (x / y) + x % y == x;

lemma_auto void shiftright_div(int x);
  requires 0 <= x;
  ensures x >> 1 == x / 2;

lemma_auto(x & y) void bitand_nonnegative(int x, int y);
  requires 0 <= y;
  ensures 0 <= (x & y) && (x & y) <= x;

lemma_auto void bitand_modulo(int x);
  requires true;
  ensures x % 2 == (x & 1);

predicate array_element<T>(T[] array, int index; T value);
predicate array_slice<T>(T[] array, int start, int end; list<T> elements);
predicate array_slice_deep<T, A, V>(T[] array, int start, int end, predicate(A, T; V) p, A info; list<T> elements, list<V> values);

lemma_auto void array_element_inv<T>();
    requires [?f]array_element<T>(?array, ?index, ?value);
    ensures [f]array_element<T>(array, index, value) &*& array != null &*& 0 <= index &*& index < array.length;

lemma_auto void array_slice_inv<T>();
    requires [?f]array_slice<T>(?array, ?start, ?end, ?elems);
    ensures [f]array_slice<T>(array, start, end, elems) &*& array != null &*& 0 <= start &*& start <= end &*& end <= array.length &*& start + length(elems) == end;

lemma_auto void array_slice_deep_inv<T, A, V>();
    requires [?f]array_slice_deep<T, A, V>(?array, ?start, ?end, ?p, ?info, ?elems, ?vs);
    ensures [f]array_slice_deep<T, A, V>(array, start, end, p, info, elems, vs) &*& array != null &*& 0 <= start &*& start <= end &*& end <= array.length &*& start + length(elems) == end;

lemma void array_slice_deep_close<T, A, V>(T[] array, int start, predicate(A, T; V) p, A a);
    requires [?f]array_slice<T>(array, start, start + 1, ?elems) &*& p(a, head(elems), ?v);
    ensures [f]array_slice_deep<T, A, V>(array, start, start + 1, p, a, elems, cons(v, nil));

lemma void array_slice_deep_open<T, A, V>(T[] array, int start);
    requires array_slice_deep<T, A, V>(array, start, start + 1, ?p, ?a, ?elems, ?vs);
    ensures array_slice<T>(array, start, start + 1, elems) &*& p(a, head(elems), head(vs));

lemma void array_slice_split<T>(T[] array, int start, int start1);
    requires array_slice<T>(array, start, ?end, ?elems) &*& start <= start1 &*& start1 <= end;
    ensures
        array_slice<T>(array, start, start1, take(start1 - start, elems)) &*&
        array_slice<T>(array, start1, end, drop(start1 - start, elems)) &*&
        elems == append(take(start1 - start, elems), drop(start1 - start, elems));

lemma void array_slice_join<T>(T[] array, int start);
    requires
        array_slice<T>(array, start, ?start1, ?elems1) &*& array_slice<T>(array, start1, ?end, ?elems2);
    ensures array_slice<T>(array, start, end, append(elems1, elems2));

lemma void array_slice_deep_split<T, A, V>(T[] array, int start, int start1);
    requires array_slice_deep<T, A, V>(array, start, ?end, ?p, ?a, ?elems, ?vs) &*& start <= start1 &*& start1 <= end;
    ensures
        array_slice_deep<T, A, V>(array, start, start1, p, a, take(start1 - start, elems), take(start1 - start, vs)) &*&
        array_slice_deep<T, A, V>(array, start1, end, p, a, drop(start1 - start, elems), drop(start1 - start, vs));

lemma void array_slice_deep_join<T, A, V>(T[] array, int start);
    requires
        array_slice_deep<T, A, V>(array, start, ?start1, ?p, ?a, ?elems1, ?vs1) &*&
        array_slice_deep<T, A, V>(array, start1, ?end, p, a, ?elems2, ?vs2);
    ensures array_slice_deep<T, A, V>(array, start, end, p, a, append(elems1, elems2), append(vs1, vs2));

lemma void array_slice_deep_empty_close<T, A, V>(T[] array, int start, predicate(A, T; V) p, A a);
    requires array != null &*& 0 <= start &*& start <= array.length;
    ensures array_slice_deep<T, A, V>(array, start, start, p, a, nil, nil);

@*/

public class Object {

    public Object();
        //@ requires emp;
        //@ ensures emp;

}

public class Class {}

public class Throwable {}

public class Exception extends Throwable {}

public class Error extends Throwable {}

public class InterruptedException {}

public class IOException extends Exception {}

public class ClosedChannelException extends IOException {}

public class RuntimeException extends Exception {

    public RuntimeException();
        //@ requires true;
        //@ ensures true;

    public RuntimeException(Object innerException);
        //@ requires true;
        //@ ensures true;

}

public class ArrayIndexOutOfBoundsException extends RuntimeException {
}

public class NullPointerException extends RuntimeException {
}

public class Byte {
    public static final byte MIN_VALUE = -128;
    public static final byte MAX_VALUE = 127;
}

public class Short {
    public static final short MIN_VALUE = -32768;
    public static final short MAX_VALUE = 32767;
}

public class Integer {

    public static final int MAX_VALUE = 0x7fffffff;
    public static final int MIN_VALUE = -0x80000000;
    
    public static int parseInt(String s);
        //@ requires s != null;
        //@ ensures true;
    

}

public class System {
    public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); // TODO: - Support more element types. - Support overlapping slices.
        //@ requires [?f]array_slice<byte>(^src, srcPos, srcPos + length, ?bs) &*& array_slice<byte>(^dest, destPos, destPos + length, _);
        //@ ensures [f]array_slice<byte>(^src, srcPos, srcPos + length, bs) &*& array_slice<byte>(^dest, destPos, destPos + length, bs);
}

public class String{
  public String();
    //@ requires emp;
    //@ ensures true;
  public String(byte[] src);
    //@ requires [?f]array_slice(src, 0, src.length, ?bs);
    //@ ensures [f]array_slice(src, 0, src.length, bs);
  public boolean equals(String other);
    //@ requires true;
    //@ ensures true;
  public int indexOf(String other);
    //@ requires true;
    //@ ensures result>=(-1);
  public String substring(int begin,int end);
    //@ requires begin>=0;
    //@ ensures result!=null;
  public int length();
    //@ requires true;
    //@ ensures result>=0;
  public boolean matches(String regex);
    //@ requires true;
    //@ ensures true;
  public boolean contains(String regex);
    //@ requires true;
    //@ ensures true;
  public static String valueOf(int value);
    //@ requires true;
    //@ ensures result != null;
  public byte[] getBytes();
    //@ requires true;
    //@ ensures result != null &*& array_slice(result, 0, result.length, _) &*& 0 <= result.length;
  public String trim();
    //@ requires true;
    //@ ensures result != null;
}

/*@

predicate_family thread_run_pre(Class c)(Runnable run, any info);
predicate_family thread_run_post(Class c)(Runnable run, any info);

@*/

public interface Runnable {
    public void run();
        //@ requires thread_run_pre(this.getClass())(this, ?info);
        //@ ensures thread_run_post(this.getClass())(this, info);
}

/*@

predicate thread(Thread thread, Runnable run);
predicate thread_started(Thread thread, Runnable run, any info);

@*/

public class Thread {
    static final int MAX_PRIORITY = 10;
    
    public Thread(Runnable run);
        //@ requires true;
        //@ ensures thread(this, run);
    
    void start();
        //@ requires thread(this, ?run) &*& thread_run_pre(run.getClass())(run, ?info);
        //@ ensures thread_started(this, run, info);
        
    void setPriority(int newPriority);
        //@ requires thread(this, ?run);
        //@ ensures thread(this, run);
}

/*@
predicate string_buffer(StringBuffer buffer);
@*/
public class StringBuffer{
  StringBuffer();
    //@ requires emp;
    //@ ensures string_buffer(this);
  StringBuffer append(StringBuffer b);
    //@ requires string_buffer(this) &*& [?f]string_buffer(b);
    //@ ensures string_buffer(this) &*& [f]string_buffer(b) &*& result==this;
  StringBuffer append(String string);
    //@ requires string_buffer(this);
    //@ ensures string_buffer(this) &*& result==this;
  String toString();
    //@ requires [?f]string_buffer(this);
    //@ ensures [f]string_buffer(this) &*& result!=null;
}
