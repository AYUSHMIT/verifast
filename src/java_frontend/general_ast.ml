(*

Copyright (C) 2013 KULeuven, Department of Computer Science, Gijs Vanspauwen
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*)

open Misc

open Num
open Big_int

(* 
  This file contains all the definitions for specifing a general intermediate 
  AST generated by the OCaml Ast_reader module after reading in the serialized 
  form generated by the Java AstVisitor in javac. To print out an AST use the 
  Ast_writer module.
*)

(* ------------------------ *)
(* AST definitions          *)
(* ------------------------ *)

(* locations *)
type srcpos = ((string * string) * int * int)
type loc = (srcpos * srcpos)


(* verifier annotations *)
type
  annotation =
  | Annotation of
      loc * 
      string                           (* Annotation: Annotation contents *)


(* names *)
and
  identifier =
  | Identifier of
      loc *
      string                           (* Identifier: Name of this identifier *)  
and
  name =
  | Name of
      loc *
      identifier list                  (* Name: Sequence of the dot-seperated identifiers of 
                                                this fully qualified name *)


(* accessibility modifiers *)
and
  accessibility =
  | PublicAccess
  | PackageAccess
  | PrivateAccess


(* types *)
and
  prim_type =
  | VoidType of loc
  | BoolType of loc
  | CharType of loc
  | ByteType of loc
  | ShortType of loc
  | IntType of loc
  | LongType of loc
  | FloatType of loc
  | DoubleType of loc
and
  ref_type =
  | SimpleRef of
      name                             (* SimpleRef: Name of the referenced type *)
  | TypeApply of
      loc *
      name *                           (* TypeApply: Name of the refererenced parameterized type *)
      ref_type list                    (* TypeApply: Type arguments for this type instantiation *)
  | WildCard of
      loc *
      ref_type option *                (* WildCard: Possible type bound of the wildcard *)
      wild_card_bound_kind             (* WildCard: Is the bound an upper or lower bound? *)
and
  wild_card_bound_kind =
  | Upper
  | Lower
and
  type_ =
  | PrimType of
      prim_type                        (* PrimType: The primitive type *)
  | RefType of                           
      ref_type                         (* RefType: The referenced type *)
  | ArrayType of
      ref_type                         (* RefType: Type of the elements in an array of this array type *)
and
  type_param =
  | TypeParam of
      loc *
      identifier *                     (* TypeParam: Identifier for this type parameter *)
      ref_type list                    (* TypeParam: List of bounds for this type parameter *)


(* package level *)
and 
  package =
  | Package of 
      loc * 
      name *                           (* Package: Package name *)
      import list *                    (* Package: Import list *)
      package_decl list                (* Package: Package declaration list *)
and
  import =
  | Import of
      loc *
      name *                           (* Import: Imported package name *)
      identifier option                (* Import: None means entire package, 
                                                  Some x means only x from specified package *)
and
  package_decl =
  | P_Annotation of 
      annotation                       (* P_Annotation: Annotation at package level *)
  | P_Class of
      interface_class_enum             (* P_Class: Interface/class/enum declaration at package level *)


(* class level *)
and
  interface_class_enum =
  | Class of
      loc *
      annotation list *                (* Class: Class annotation list (VeriFast style) *)
      identifier *                     (* Class: Identifier for this class *)
      type_param list *                (* Class: The type parameters of this class *)
      accessibility *                  (* Class: Is this class public, package or private? *)
      bool *                           (* Class: Is this class abstract? *)
      bool *                           (* Class: Is this class final? *)
      bool *                           (* Class: Is this class static? *)
      ref_type option *                (* Class: None means this class does not extend some other class
                                                 Some x means this class extends x *)
      ref_type list *                  (* Class: List of interfaces that this class implements *)
      class_decl list                  (* Class: List of declarations from this class in order *)
  | Interface of
      loc *
      annotation list *                (* Interface: Interface annotation list (VeriFast style) *)
      identifier *                     (* Interface: Identifier for this interface *)
      type_param list *                (* Interface: The type parameters of this interface *)
      accessibility *                  (* Interface: Is this interface public, package or private? *)
      ref_type list *                  (* Interface: List of interfaces that this interface extends *)
      class_decl list                  (* Interface: List of declarations from this interface in order *)
  | Enum of
      loc *
      annotation list *                (* Enum: Enum annotation list (VeriFast style) *)
      identifier *                     (* Enum: Identifier for this enum *)
      accessibility *                  (* Enum: Is this enum public, package or private? *)
      identifier list                  (* Enum: List of enumerators for this enumeration *)
                    (* 
                    Only simple enumerations are supported, e.g:
                      public enum Foo
                      {
                        First,
                        Second;
                      }
                    No method (including constructors) or instance 
                    variable declarations are allowed inside an enum
                    *)
and
  class_decl =
  | C_Variable of
      variable_decl                    (* C_Var: Variable declaration at class level 
                                                (i.e. instance variable) *)
  | C_Method of
      method_decl                      (* C_Method: Method (or constructor) declaration *)
  | C_Annotation of  
      annotation                       (* C_Annotation: Annotation at class level *)
  | C_Class of
      interface_class_enum             (* C_Class: Interface/class/enum declaration at class level 
                                                  (i.e. inner class) *)
and
  method_decl =
  | Constructor of
      loc *
      annotation list *                (* Constructor: Consructor annotation list (VeriFast style) *)
      identifier *                     (* Constructor: Identifier for this constructor *)
      type_param list *                (* Constructor: The type parameters of this constructor *)
      accessibility *                  (* Constructor: Is this constructor public, package or private? *)
      bool *                           (* Constructor: Is this constructor protected?, 
                                                       if so the accessibility is meaningless *)
      variable_decl list *             (* Constructor: The parameters for this constructor *)
      (ref_type * annotation) list *   (* Constructor: List of possible thrown exceptions together with their annotations *)
      statement list *                 (* Constructor: Possible statements in body of constructor *)
      bool                             (* Constructor: Is this constructor auto generated? *)
  | Method of
      loc *
      annotation list *                (* Method: Method annotation list (VeriFast style) *)
      identifier *                     (* Method: Identifier for this method *)
      type_param list *                (* Method: The type parameters of this method *)
      accessibility *                  (* Method: Is this method public, package or private? *)
      bool *                           (* Method: Is this method protected?, 
                                                  if so the accessibility is meaningless *)
      bool *                           (* Method: Is this method abstract? *)
      bool *                           (* Method: Is this method final? *)
      bool *                           (* Method: Is this method static? *)
      type_ *                          (* Method: The return type of this method *)
      variable_decl list *             (* Method: The parameters for this method *)
      (ref_type * annotation) list *   (* Method: List of possible thrown exceptions together with their annotations *)
      statement list option            (* Method: Possible statements in body of function *)
and
  variable_decl =
  | Variable of
      loc *
      identifier *                     (* Variable: Name *)
      accessibility *                  (* Variable: Is this variable public, package or private? *)
      bool *                           (* Variable: Is this variable protected?, 
                                                    if so the accessibility is meaningless *)
      bool *                           (* Variable: Is this variable final? *)
      bool *                           (* Variable: Is this variable static? *)
      type_ *                          (* Variable: The type of this variable *)
      expression option                (* Variable: Possible initializing expression *)


(* statements *)
and
  statement =
  | S_Annotation of
      annotation
  | S_Variable of
      variable_decl
  | S_Expression of
      expression
  | Block of
      loc *
      statement list                   (* Block: List of statements in this block *)
  | Try of
      loc *
      statement list *                 (* Try: Body of this try block *)
      catch list                       (* Try: List of catch blocks associated with this try block *)
  | DoWhile of
      loc *
      annotation list *                (* DoWhile: Loop annotation list (VeriFast style) *)
      expression *                     (* DoWhile: Loop condition of this loop as an expression *)
      statement list                   (* DoWhile: Body of this loop *)
  | While of
      loc *
      annotation list *                (* While: Loop annotation list (VeriFast style) *)
      expression *                     (* While: Loop condition of this loop as an expression *)
      statement list                   (* While: Body of this loop *)
  | For of
      loc *
      annotation list *                (* For: Loop annotation list (VeriFast style) *)
      statement list *                 (* For: Initializing statements of this for loop (i.e. for( * ; ; )) *)
      expression *                     (* For: Loop condition of loop as an expression  (i.e. for( ; * ; )) *)
      statement list *                 (* For: Updating statements of this for loop     (i.e. for( ; ; * )) *)
      statement list                   (* For: Body of this loop *)
  | Foreach of
      loc *
      annotation list *                (* Foreach: Loop annotation list (VeriFast style) *)
      variable_decl *                  (* Foreach: Variable declaration for the loop variable *)
      expression *                     (* Foreach: Container to loop over as an expression *)
      statement list                   (* Foreach: Body of this loop *)
(*  | Labelled of
      loc *
      identifier *                     (* Labelled: The name of the label of this labelled statement *)  
      statement                        (* Labelled: Body of this labelled statement *)
  | Switch of
      loc *
      expression *                     (* Switch: Selector of this switch statement *)  
      case list                        (* Switch: List of cases in this switch statement *)*)
  | If of
      loc *
      expression *                     (* If: Branching condition for this conditional *)
      statement *                      (* If: If branch of this conditional *)
      statement                        (* If: Else branch of this conditional *)
(*  | Break of 
      loc
  | Continue of 
      loc*)
  | Return of
      loc *
      expression                       (* Return: Expression that is returned by this return statement *)
  | Throw of
      loc *
      expression                       (* Throw: Expression (which should be Throwable) that is thrown 
                                                 by this throw statement *)
(*  | Assert of
      loc *
      expression *                     (* Assert: Failing condition for this assert *)
      expression                       (* Assert: Detailed information (implicit String conversion when
                                                  evaluated) associated with this assert *)
and
  case =
  | Case of 
      loc *
      expression *                     (* Case: Pattern matched by this case from a switch statment *)
      statement list                   (* Case: List of statements in this case from a switch statment *)*)
and
  catch =
  | Catch of 
      loc *
      variable_decl *                  (* Catch: Declaration of Throwable object that is catched by 
                                                 this catch block *)
      statement list                   (* Catch: Body of this catch block *)

(* expressions *)
and
  expression =
  | E_Identifier of
      identifier
  | Access of
      loc *
      expression *
      identifier
  | Apply of
      loc *
      type_param list *                (* Apply: List of type parameters for this method invocation *)
      expression *                     (* Apply: Method that is called *)
      expression list                  (* Apply: List of arguments provided for this method invocation *)
  | NewClass of
      loc *
      type_param list *                (* NewClass: List of type parameters for this constructor 
                                                    invocation *)
      ref_type *                       (* NewClass: Type of the class that is instantiated *)
      expression list                  (* NewClass: List of arguments provided for this constructor 
                                                    invocation *)
  | NewArray of
      loc *
      type_ *                          (* NewArray: Type of elements in the newly created array *)
(*       TODO: fix multidimentional arrays *)
(*       expression *                     (* NewArray: Number of elements in the allocated array *) *)
      expression list                  (* NewArray: List of expressions to initialize the newly created array *)
  | Assign of
      loc *                      
      bin_operator option *            (* Assign: Possible binary operator for this assigment: 
                                                  e.g. 'None' means just '=' (no operator), 'some O_Plus' means '+=' *)
      expression *                     (* Assign: Left hand side of this assignment *)
      expression                       (* Assign: Right hand side of this assignment *)
  | Unary of
      loc *                      
      uni_operator *                   (* Unary: Operator in this unary expression *)
      expression                       (* Unary: Only argument to this unary operator *)
  | Binary of
      loc *                      
      bin_operator *                   (* Unary: Operator in this binary expression  *)
      expression *                     (* Unary: Left hand side argument to this binary operator *)
      expression                       (* Unary: Right hand side argument to this binary operator *)
  | TypeCast of
      loc *
      type_ *                          (* TypeCast: Type to cast the given expression to *)
      expression                       (* TypeCast: Expression which is cast do the speciefied type 
  | TypeTest of
      loc *
      type_ *                          (* TypeTest: Type to check the given expression's type against *)
      expression                       (* TypeTest: Expression which is tested for its type *)
  | ArrayAccess of
      loc *
      expression *                     (* ArrayAccess: Array that is indexed *)
      expression                       (* ArrayAccess: Index of array access *)*)
  | Select of
      loc *
      expression *                     (* Select: Object that is inspected *)
      name                             (* Select: Name of selected member *)
  | Literal of
      loc *                            
      type_ *                          (* Literal: Type of this literal:
                                         -If type_ is a prim_type then the meaning is clear
                                         -If type_ is a reftype ten it must be a String literal,
                                         otherwise it is considered as the "null" literal *)
      string                           (* Literal: Value of this literal as a string *)
and 
  bin_operator =
  | O_Plus                             (* + *)
  | O_Min                              (* - *)
  | O_Mul                              (* * *)
  | O_Div                              (* / *)
  | O_Mod                              (* % *)
  | O_Or                               (* || *)
  | O_And                              (* && *)
  | O_Eq                               (* == *)
  | O_NotEq                            (* != *)
  | O_Lt                               (* < *)
  | O_Gt                               (* > *)
  | O_LtEq                             (* <= *)
  | O_GtEq                             (* >= *)
  | O_BitOr                            (* | *)
  | O_BitXor                           (* ^ *)
  | O_BitAnd                           (* & *)
and
  uni_operator=
  | O_Pos                              (* + *)
  | O_Neg                              (* - *)
  | O_Not                              (* ! *)
  | O_Compl                            (* ~ *)
  | O_PreInc                           (* ++var *)
  | O_PreDec                           (* --var *) 
  | O_PostInc                          (* var++ *)
  | O_PostDec                          (* var-- *)
  | O_ShiftL                           (* << *)
  | O_ShiftR                           (* >> *)
  | O_UShiftR                          (* >>> *)


(* -------------------------- *)
(* AST construction functions *)
(* -------------------------- *)

(* dummies *)
let dummy_srcpos = (("<nowhere>", "source"), 0, 0)
let dummy_loc = (dummy_srcpos, dummy_srcpos)
let dummy_ident = Identifier(dummy_loc, "")
let dummy_name = Name(dummy_loc, [])
let dummy_package = Package(dummy_loc, Name(dummy_loc, []), [], [])

(* x_of_string *)
let name_of_string l name=
  let parts = List.map (fun x -> Identifier(l, x)) (split_string '.' name) in
  Name(l, parts)
let prim_type_of_string l t =
  if (t = "void") then VoidType(l)
  else if (t = "boolean") then BoolType(l)
  else if (t = "char") then CharType(l)
  else if (t = "byte") then ByteType(l)
  else if (t = "short") then ShortType(l)
  else if (t = "int") then IntType(l)
  else if (t = "long") then LongType(l)
  else if (t = "float") then FloatType(l)
  else if (t = "double") then DoubleType(l)
  else assert(false)    
let u_operator_of_string o =
  if (o = "+") then O_Pos
  else if (o = "-") then O_Neg
  else if (o = "!") then O_Not
  else if (o = "~") then O_Compl
  else if (o = "++x") then O_PreInc
  else if (o = "--x") then O_PreDec
  else if (o = "x++") then O_PostInc
  else if (o = "x--") then O_PreDec
  else if (o = "<<") then O_ShiftL
(*   else if (o = ">>") then O_ShiftR *)
  else if (o = ">>>") then O_UShiftR 
  else assert(false)    
let b_operator_of_string o =
  if (o = "+") then O_Plus
  else if (o = "-") then O_Min
  else if (o = "*") then O_Mul
  else if (o = "/") then O_Div
  else if (o = "%") then O_Mod
  else if (o = "||") then O_Or
  else if (o = "&&") then O_And
  else if (o = "==") then O_Eq
  else if (o = "!=") then O_NotEq
  else if (o = "<") then O_Lt
  else if (o = ">") then O_Gt
  else if (o = "<=") then O_LtEq
  else if (o = ">=") then O_GtEq
  else if (o = "|") then O_BitOr
  else if (o = "^") then O_BitXor
  else if (o = "&") then O_BitAnd
  else assert(false)

(* -------------------------- *)
(* AST inspection functions   *)
(* -------------------------- *)

(* string_of_x *)
let string_of_srcpos (p,l,c) = p ^ "(" ^ string_of_int l ^ "," ^ string_of_int c ^ ")"
let string_of_path (basedir, relpath) = concat basedir relpath
let string_of_loc ((p1, l1, c1), (p2, l2, c2)) =
  string_of_path p1 ^ "(" ^ string_of_int l1 ^ "," ^ string_of_int c1 ^
  if p1 = p2 then
    if l1 = l2 then
      if c1 = c2 then
        ")"
      else
        "-" ^ string_of_int c2 ^ ")"
    else
      "-" ^ string_of_int l2 ^ "," ^ string_of_int c2 ^ ")"
  else
    ")-" ^ string_of_path p2 ^ "(" ^ string_of_int l2 ^ "," ^ string_of_int c2 ^ ")" 
let string_of_identifier id =
  match id with Identifier(_, name) -> name
let string_of_name name =
  match name with Name(_, parts) -> String.concat "." (List.map string_of_identifier parts)
let string_of_annotation ann =
  match ann with Annotation(_, a) -> a
let string_of_prim_type t =
  match t with
  | VoidType _ -> "void"
  | BoolType _ -> "boolean"
  | CharType _ -> "char"
  | ByteType _ -> "byte"
  | ShortType _ -> "short"
  | IntType _ -> "int"
  | LongType _ -> "long"
  | FloatType _ -> "float"
  | DoubleType _ -> "double"
let rec string_of_ref_type t =
  match t with
  | SimpleRef n -> string_of_name n
  | TypeApply(l, n, args) ->
      (string_of_name n) ^ 
      (if List.length args > 0 then
        "<" ^ (String.concat ", " (List.map string_of_ref_type args)) ^ ">"
       else
        "" )
  | WildCard(l, typ, kind) ->
      match typ with
        Some(typ) ->
          "? " ^ (if kind = Upper then "extends " else "super ") ^ (string_of_ref_type typ)
      | None -> "?"
and string_of_type t =
  match t with
  | PrimType t -> string_of_prim_type t
  | RefType t -> string_of_ref_type t
  | ArrayType t -> string_of_ref_type t
let string_of_accessibility access =
  match access with
    PublicAccess -> "public"
  | PackageAccess -> "package"
  | PrivateAccess -> "private"

(* string_equals_x *)
let string_equals_identifier s n =
  s = string_of_identifier n 
let string_equals_name s n =
  s = string_of_name n

(* misc *)
let remove_last_id name=
  match name with
    Name((l1,l2), parts) ->
      if List.length parts > 0 then
        let id = get_last parts in
        let l2' =
          match id with 
            Identifier((l, _), _) -> l
        in
        (Name((l1,l2'), remove_last parts), id)
      else
        (name, Identifier(dummy_loc, ""))

(* -------------------------- *)
(* End                        *)
(* -------------------------- *)





























