package java.util.concurrent.locks;
/*@@*/

/*@
predicate lock(Lock l, predicate() inv);

lemma void lock_fractions_split(Lock l, real coef);
    requires [?f]lock(l, ?a) &*& 0 < coef &*& coef < 1;
    ensures [coef * f]lock(l, a) &*& [(1 - coef) * f]lock(l, a);

lemma void lock_fractions_merge(Lock l);
    requires [?f1]lock(l, ?a1) &*& [?f2]lock(l, ?a2);
    ensures [f1 + f2]lock(l, a1) &*& a2 == a1;

predicate create_lock_ghost_arg(predicate() inv)
    requires inv();

@*/
public interface Lock {
  void lock();
    //@ requires [?f]lock(this, ?a);
    //@ ensures [f]lock(this, a) &*& a();

  void unlock();
    //@ requires [?f]lock(this, ?a) &*& a();
    //@ ensures [f]lock(this, a);
}
public class ReentrantLock extends Object implements Lock{
  public ReentrantLock();
      //@ requires create_lock_ghost_arg(?a);
      //@ ensures lock(result, a);
}