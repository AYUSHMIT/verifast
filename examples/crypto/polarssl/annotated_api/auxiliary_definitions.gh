#ifndef AUXILIARY_DEFINITIONS_GH
#define AUXILIARY_DEFINITIONS_GH

#include "nat.gh"
#include "list.gh"
#include "listex.gh"

//Bad protocol principal (e.g the polarssl_attacker)
fixpoint bool bad(int principal);

//Collisions
fixpoint bool collision_in_run();

//Int pairs, to encode information
fixpoint int int_left(int p);
fixpoint int int_right(int p);
fixpoint int int_pair(int f, int s);

lemma_auto void int_left_int_pair(int f, int s);
  requires true;
  ensures  int_left(int_pair(f, s)) == f;

lemma_auto void int_right_int_pair(int f, int s);
  requires true;
  ensures  int_right(int_pair(f, s)) == s;

//The optional string type
predicate option_string(char *s; list<char> cs) =
    s == 0 ?
        cs == nil
    :
        string(s, cs);

//Hide a char chunck
predicate hide_chars(char *buffer, int length, list<char> cs) =
  chars(buffer, length, cs)
;

//Power fixpoint
fixpoint int pow(int n, nat e) 
{
  switch (e)
  {
    case succ(e0): return n * pow(n, e0);
    case zero: return 1;
  }
}

//Maximum/minimum of a list of ints
fixpoint int maximum(list<int> ints)
{
  switch (ints)
  {
    case cons(i, r_ints): 
       return i >= maximum(r_ints) ?
         i
       :
         maximum(r_ints);
    case nil: 
      return INT_MIN;
  }
}

fixpoint int minimum(list<int> ints)
{
  switch (ints)
  {
    case cons(i, r_ints): 
       return i <= minimum(r_ints) ?
         i
       :
         minimum(r_ints);
    case nil: 
      return INT_MAX;
  }
}

//Union of two set lists
fixpoint bool not_contains<t>(list<t> xs, t x) { return false == mem(x, xs); }

fixpoint list<t> union<t>(list<t> xs, list<t> ys) 
{ 
  return append(xs, filter((not_contains)(xs), ys)); 
}

lemma void union_nil<t>(list<t> xs);
    requires true;
    ensures union(xs, nil) == xs && union(nil, xs) == xs;

lemma void subset_union<t>(list<t> xs, list<t> ys);
    requires subset(xs, ys) == true;
    ensures union(ys, xs) == ys;

lemma void union_refl<t>(list<t> xs);
    requires true;
    ensures union(xs, xs) == xs;

#endif
