#ifndef ATTACKER_PROOF_OBLIGATIONS_H
#define ATTACKER_PROOF_OBLIGATIONS_H

#define PACK_ATTACKER_PROOF_OBLIGATIONS(PREFIX) \
{ \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_data) : \
    can_send_data(PREFIX##_pub)(PREFIX##_data){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_public_pair) : \
    can_send_public_pair(PREFIX##_pub)(PREFIX##_ii1, PREFIX##_ii2){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_decomposed_public_pair) : \
    can_send_decomposed_public_pair(PREFIX##_pub)(PREFIX##_pair){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_bad_principal_nonce) : \
    can_send_bad_principal_nonce(PREFIX##_pub)(PREFIX##_nonce){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_incremented_nonce) : \
    can_send_incremented_nonce(PREFIX##_pub)(PREFIX##_nonce){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_bad_principal_keys) : \
    can_send_bad_principal_keys(PREFIX##_pub)(PREFIX##_p){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_public_hmac) : \
    can_send_public_hmac(PREFIX##_pub)(PREFIX##_key, PREFIX##_payload, PREFIX##_hmac){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_public_encrypted) : \
    can_send_public_encrypted(PREFIX##_pub)(PREFIX##_key, PREFIX##_pay, PREFIX##_enc){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_public_decrypted) : \
    can_send_public_decrypted(PREFIX##_pub)(PREFIX##_key, PREFIX##_pay, PREFIX##_enc){ call(); }; \
}

#define ATTACKER_PROOFS_DEFAULT(PREFIX) \
  DEFAULT_CAN_SEND_DATA(PREFIX) \
  DEFAULT_CAN_SEND_PUBLIC_PAIR(PREFIX) \
  DEFAULT_CAN_SEND_DECOMPOSED_PUBLIC_PAIR(PREFIX) \
  DEFAULT_CAN_SEND_BAD_PRINCIPAL_NONCE(PREFIX) \
  DEFAULT_CAN_SEND_INCREMENTED_NONCE(PREFIX) \
  DEFAULT_CAN_SEND_BAD_PRINCIPAL_KEYS(PREFIX) \
  DEFAULT_CAN_SEND_PUBLIC_HMAC(PREFIX) \
  DEFAULT_CAN_SEND_PUBLIC_ENCRYPTED(PREFIX) \
  DEFAULT_CAN_SEND_PUBLIC_DECRYPTED(PREFIX) \

#define DEFAULT_CAN_SEND_DATA(PREFIX) \
lemma void PREFIX##_can_send_data(int data) \
  requires [?f0]world(PREFIX##_pub); \
  ensures  [f0]world(PREFIX##_pub) &*& \
           PREFIX##_pub(data_item(data)) == true; \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_PUBLIC_PAIR(PREFIX) \
lemma void PREFIX##_can_send_public_pair(struct item* first, struct item* second) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(first, ?f_item) &*& item(second, ?s_item) &*& \
            true == if_no_collision( \
              PREFIX##_pub(f_item) && PREFIX##_pub(s_item) \
            ); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(first, f_item) &*& item(second, s_item) &*& \
            true == if_no_collision( \
              PREFIX##_pub(pair_item(f_item, s_item)) == true \
            ); \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_DECOMPOSED_PUBLIC_PAIR(PREFIX) \
lemma void PREFIX##_can_send_decomposed_public_pair(struct item* pair) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(pair, pair_item(?i1, ?i2)) &*& \
            true == if_no_collision( \
              PREFIX##_pub(pair_item(i1, i2)) == true \
            ); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(pair, pair_item(i1, i2)) &*& \
            true == if_no_collision( \
              PREFIX##_pub(i1) && PREFIX##_pub(i2) \
            ); \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_BAD_PRINCIPAL_NONCE(PREFIX) \
lemma void PREFIX##_can_send_bad_principal_nonce(struct item* nonce) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(nonce, nonce_item(?p, ?c, ?inc, ?i)) &*& \
            bad(p) == true; \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(nonce, nonce_item(p, c, inc, i)) &*& \
            PREFIX##_pub(nonce_item(p, c, inc, i)) == true; \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_INCREMENTED_NONCE(PREFIX) \
lemma void PREFIX##_can_send_incremented_nonce(struct item* nonce) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(nonce, ?ni) &*& ni == nonce_item(?p, ?c, ?inc, ?i) &*& \
            true == if_no_collision( \
              PREFIX##_pub(ni) == true \
            ); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(nonce, ni) &*& \
            true == if_no_collision( \
              PREFIX##_pub(nonce_item(p, c, inc + 1, i)) == true \
            ); \
{ \
  assert true; \
}
            
#define DEFAULT_CAN_SEND_BAD_PRINCIPAL_KEYS(PREFIX) \
lemma void PREFIX##_can_send_bad_principal_keys(int p) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(?item, key_item(p, ?c, ?k, ?i)) &*& \
            bad(p) == true; \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(item, key_item(p, c, k, i)) &*& \
            PREFIX##_pub(key_item(p, c, k, i)) == true; \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_PUBLIC_HMAC(PREFIX) \
lemma void PREFIX##_can_send_public_hmac(struct item* key, \
                                         struct item* payload, \
                                         struct item* hmac) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(key, ?k_item) &*& k_item == key_item(?p, ?c, ?k, ?i) &*& \
            item(payload, ?p_item) &*& item(hmac, ?h_item) &*& \
            true == if_no_collision( \
              h_item == hmac_item(k_item, p_item) && \
              PREFIX##_pub(k_item) && PREFIX##_pub(p_item) \
            ); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(key, k_item) &*& item(payload, p_item) &*& \
            item(hmac, h_item) &*& \
            true == if_no_collision( \
              PREFIX##_pub(h_item) == true \
            ); \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_PUBLIC_ENCRYPTED(PREFIX) \
lemma void PREFIX##_can_send_public_encrypted (struct item* key, \
                                               struct item* payload, \
                                               struct item* encrypted) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(key, ?k_item) &*& k_item == key_item(?p, ?c, ?k, ?i) &*& \
            item(payload, ?p_item) &*& \
            item(encrypted, ?e_item) &*& \
            e_item == encrypted_item(?k_item', ?p_item', ?e) &*& \
            true == if_no_collision( \
              PREFIX##_pub(k_item) == true && PREFIX##_pub(p_item) == true && \
              k_item == k_item' && p_item == p_item' \
            ); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(key, k_item) &*& item(payload, p_item) &*& \
            item(encrypted, e_item) &*& \
            true == if_no_collision( \
              PREFIX##_pub(e_item) == true \
            ); \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_PUBLIC_DECRYPTED(PREFIX) \
  DEPTH_CAN_SEND_PUBLIC_DECRYPTED(PREFIX, 1)

#define DEPTH_CAN_SEND_PUBLIC_DECRYPTED(PREFIX, DEPTH) \
lemma void PREFIX##_can_send_public_decrypted (struct item* key, \
                                               struct item* payload, \
                                               struct item* encrypted) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(key, ?k_item) &*& \
              k_item == key_item(?p, ?c, ?k, ?i) &*& \
            item(encrypted, ?e_item) &*& \
              e_item == encrypted_item(?enc_key, ?enc_pay, _) &*& \
            item(payload, ?p_item) &*& \
            true == if_no_collision( \
              PREFIX##_pub(k_item) == true && \
              PREFIX##_pub(e_item) == true && \
              enc_key == key_item(p, c, inverse_key_kind(k), i) && \
              p_item == enc_pay \
            ); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(key, k_item) &*& item(encrypted, e_item) &*& \
            item(payload, p_item) &*& \
            true == if_no_collision( \
              PREFIX##_pub(p_item) == true \
            ); \
{ \
  SWITCH_CRYPTO_PRIMITIVES(payload, 1, DEPTH); \
}


#endif
