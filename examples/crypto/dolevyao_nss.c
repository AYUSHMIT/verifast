// Dolev-Yao security verification of the Needham-Schroeder symmetric key protocol
// See explanations in dolevyao_rpc.c

#include "stdlib.h"

/*

// 1. A -> B. A
// 2. B -> A. {A, NB1}_K(BS)
// 3. A -> S. A, B, NA, {A, NB1}_K(BS)
// 5. A -> B. {K(AB), A, NB1}_K(BS)
// 4. S -> A. {NA, K(AB), B, {K(AB), A, NB1}_K(BS)}_K(AS)
// 6. B -> A. {NB2}_K(AB)
// 7. A -> B. {NB2 + 1}_K(AB)

// Goal: A and B share a symmetric encryption session key K(AB)

*/

///////////////////////////////////////////////////////////////////////////////
// General definitions ////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*@ 

predicate world(fixpoint(item, bool) pub);
fixpoint bool bad(int principal);

fixpoint int int_left(int p);
fixpoint int int_right(int p);
fixpoint int int_pair(int f, int s);

lemma_auto void int_left_int_pair(int f, int s);
  requires true;
  ensures int_left(int_pair(f, s)) == f;

lemma_auto void int_right_int_pair(int f, int s);
  requires true;
  ensures int_right(int_pair(f, s)) == s;
    
@*/

///////////////////////////////////////////////////////////////////////////////
// Item definitions ///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct item;

/*@

inductive item =
  | nonce_item(int principal, int count, int info)
  // "server_key_item" represents the key for communication with the trusted key server
  | server_key_item(int principal, int info)
  // "session_key_item" represents the key shared bewteen two principals for bidirectional 
  // communication initiated by the sender
  | session_key_item(int sender, int receiver, int count, int info)
  | data_item(int data)
  | encrypted_item(int sender, int receiver, int count, int info, item payload, int entropy)
  | pair_item(item first, item second);
  
predicate item(struct item *item, item i);

@*/

bool item_equals(struct item *item1, struct item *item2);
  //@ requires item(item1, ?i1) &*& item(item2, ?i2);
  //@ ensures item(item1, i1) &*& item(item2, i2) &*& result == (i1 == i2);

void item_free(struct item *item);
  //@ requires item(item, _);
  //@ ensures true;

///////////////////////////////////////////////////////////////////////////////
// Principals /////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*@

// Keeps track of the number of principals generated, so as to ensure unique principal ids
predicate principals(int count);

// Keeps track of the number of nonces generated by principal
predicate generated_nonces(int principal, int count);

// Keeps track of the number of session keys generated by server
predicate generated_keys(int count);

// Principal 0 is the key server, which any principal shares a secret symmetric key with
predicate initial_principals()=
  principals(1) &*& generated_keys(0);

@*/

//@ predicate create_principal_request(int info) = emp;

struct item *create_principal();
  //@ requires principals(?count) &*& create_principal_request(?info);
  /*@ ensures principals(count + 1) &*& item(result, server_key_item(count, info))
              &*& generated_nonces(count, 0); @*/
  
///////////////////////////////////////////////////////////////////////////////
// Nonce item /////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//@ predicate nonce_request(int principal, int info) = emp;

struct item *create_nonce();
  /*@ requires generated_nonces(?principal, ?count) &*& 
               nonce_request(principal, ?info); @*/
  /*@ ensures generated_nonces(principal, count + 1) &*&
              item(result, nonce_item(principal, count, info)); @*/

struct item *increment_nonce(struct item *item, int amount);
  //@ requires item(item, nonce_item(?principal, ?count, ?info));
  /*@ ensures item(item, nonce_item(principal, count, info)) &*& 
              item(result, nonce_item(principal, count, int_pair(amount,info))); @*/

// check_is_nonce aborts if the item is not a nonce
void check_is_nonce(struct item *item);
  //@ requires item(item, ?i);
  /*@
      ensures
        switch (i) 
        {
          case nonce_item(p, count, info): return item(item, nonce_item(p, count, info));
          case server_key_item(p, info): return false;
          case session_key_item(s, r, count, info): return false;
          case data_item(d): return false;
          case encrypted_item(s, r, count, info, payload, entropy): return false;
          case pair_item(f, s): return false;
        };
  @*/

///////////////////////////////////////////////////////////////////////////////
// Key item ///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*@
predicate key_item(struct item *item, int sender, int receiver, int count, int info) =  
  receiver == 0 ?
    // Principal 0 is the trusted key server
    count == 0 &*& item(item, server_key_item(sender, info))
  :
    item(item, session_key_item(sender, receiver, count, info));
@*/

///////////////////////////////////////////////////////////////////////////////
// Server key item ////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//@ predicate server_key_request(int info) = emp;

struct item *get_server_key(int participant);
  /*@ requires server_key_request(?info) &*&
               generated_keys(?count); @*/
  /*@ ensures key_item(result, participant, 0, 0, info) &*& 
              generated_keys(count); @*/

///////////////////////////////////////////////////////////////////////////////
// Session key item ///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//TODO: is this oke?

//@ predicate session_key_request(int sender, int receiver, int info) = emp;

struct item *create_session_key();
  /*@ requires session_key_request(?sender, ?receiver, ?info) &*& 
               generated_keys(?count); @*/
  /*@ ensures item(result, session_key_item(sender, receiver, count, info)) &*& 
              generated_keys(count + 1); @*/

//check_is_key aborts if the item is not a key.
void check_is_session_key(struct item *item);
  //@ requires item(item, ?i) &*& session_key_request(?sender, ?receiver, ?info);
  /*@
      ensures
        switch (i) 
        {
          case nonce_item(p0, count0, info0): return false;
          case server_key_item(p0, info0): return false;
          case session_key_item(s0, r0, count0, info0):
            return sender == s0 && receiver == r0 && info == info0 ? 
              key_item(item, s0, r0, count0, info0) : false;
          case data_item(d0): return false;
          case encrypted_item(s0, r0, count0, info0, payload0, entropy0): return false;
          case pair_item(f0, s0): return false;
       };
  @*/

///////////////////////////////////////////////////////////////////////////////
// Data item //////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct item *create_data_item(int data);
  //@ requires true;
  //@ ensures item(result, data_item(data));

// item_get_data aborts if the item is not a data item.
int item_get_data(struct item *item);
  //@ requires item(item, ?i);
  /*@
      ensures
        switch (i) {
          case nonce_item(p, count, info): return false;
          case server_key_item(p, info): return false;
          case session_key_item(s, r, count, info): return false;
          case data_item(d): return item(item, i) &*& result == d;
          case encrypted_item(s, r, count, info, payload, entropy): return false;
          case pair_item(f, s): return false;
        };
  @*/

///////////////////////////////////////////////////////////////////////////////
// Encrypted item /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//@ predicate entropy(int value) = true;

// This function aborts if the key is not a key item.
struct item *encrypt(struct item *key, struct item *payload);
  //@ requires key_item(key, ?s, ?r, ?count, ?info) &*& item(payload, ?p);
  /*@ 
      ensures key_item(key, s, r, count, info) &*& 
              item(payload, p) &*& [_]entropy(?entropy) &*& 
              item(result, encrypted_item(s, r, count, info, p, entropy)); 
  @*/

// This function aborts if the key is not a key item.
struct item *decrypt(struct item *key, struct item *item);
  //@ requires key_item(key, ?s, ?r, ?count, ?info) &*& item(item, ?i);
  /*@
      ensures
        key_item(key, s, r, count, info) &*& item(item, i) &*&
        switch (i) {
          case nonce_item(p0, count0, info0): return false;
          case server_key_item(p, info0): return false;
          case session_key_item(r0, s0, count0, info0): return false;
          case data_item(d): return false;
          case encrypted_item(s0, r0, count0, info0, p, entropy):
               return r0 == r &*& s0 == s &*& count0 == count &*& 
                     info0 == info &*& item(result, p);
          case pair_item(f0, s0): return false;
        };
  @*/

///////////////////////////////////////////////////////////////////////////////
// Pair item //////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct item *create_pair(struct item *first, struct item *second);
  //@ requires item(first, ?f) &*& item(second, ?s);
  //@ ensures item(first, f) &*& item(second, s) &*& item(result, pair_item(f, s));

struct item *pair_get_first(struct item *pair);
  //@ requires item(pair, ?p);
  /*@
      ensures
        item(pair, p) &*&
        switch (p) {
          case nonce_item(s, count, info): return false;
          case server_key_item(s, info): return false;
          case session_key_item(s, r, count, info): return false;
          case data_item(d): return false;
          case encrypted_item(s, r, count, info, payload, entropy): return false;
          case pair_item(f, s): return item(result, f);
        };
  @*/

struct item *pair_get_second(struct item *pair);
  //@ requires item(pair, ?p);
  /*@
      ensures
        item(pair, p) &*&
        switch (p) {
          case nonce_item(s, count, info): return false;
          case server_key_item(s, info): return false;
          case session_key_item(s, r, count, info): return false;
          case data_item(d): return false;
          case encrypted_item(s, r, count, info, payload, entropy): return false;
          case pair_item(f, s): return item(result, s);
        };
  @*/

///////////////////////////////////////////////////////////////////////////////
// Network ////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void net_send(struct item *datagram);
  //@ requires world(?pub) &*& item(datagram, ?d) &*& pub(d) == true;
  //@ ensures world(pub) &*& item(datagram, d);

struct item *net_receive();
  //@ requires world(?pub);
  //@ ensures world(pub) &*& item(result, ?d) &*& pub(d) == true;

///////////////////////////////////////////////////////////////////////////////
// Definition of "pub" for this protocol //////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// info:
//   *Encryption:
//     int_pair(0, 0)
//   *Nonces:
//     int_pair(1, int_pair(A, B)): NB1 
//     int_pair(2, int_pair(A, B)): NA
//     int_pair(3, int_pair(A, B)): NB2
//     int_pair(4, int_pair(3, int_pair(A, B))): NB2 + 1

/*@

// A definition of "pub" for the example protocol.
fixpoint bool mypub(item i) 
{
  switch (i) 
  {
    case nonce_item(s, count, info): 
      //NA
      return true;
    case server_key_item(r, info): 
      //-
      return bad(0) || bad(r);
    case session_key_item(s, r, count, info):
      //-
      return bad(0) || bad(s) || bad(r);
    case data_item(d): 
      //A,B
      return true;
    case encrypted_item(s, r, count, info, m, entropy): 
      return mypub(m) || info == int_pair(0,0) &&
        switch(m)
        {
          case nonce_item(s0, count0, info0): return
            r == s0 &&
            (
              //{NB2}_K(AB)
              info0 == int_pair(3, int_pair(s, r)) ||
              //{NB2 + 1}_K(AB)
              info0 == int_pair(4, int_pair(3, int_pair(s, r)))
            );
          case pair_item(first0, second0): return
            switch(second0)
            {
              //{A, NB1}_K(BS)
              case nonce_item(s1, count1, info1): return
                r == 0 && count == 0 &&
                switch(first0)
                {
                  case data_item(s2): return
                    //A
                    s2 == s &&
                    //NB1
                    s1 == r && info1 == int_pair(1, int_pair(s, r));
                  default: return false;
                };
              case pair_item(first1, second1): return
                switch(second1)
                {
                  //{K(AB), A, NB1}_K(BS)
                  case nonce_item(s2, count2, info2): return
                    r == 0 && count == 0 &&
                    switch(first0)
                    {
                      case session_key_item(s3, r3, count3, info3): return
                        s3 == s && r3 == s &&
                        //K(AB)
                        info3 == int_pair(0, 0) &&
                        //A
                        first1 == data_item(s) &&
                        //NB1
                        s2 == r && info2 == int_pair(1, int_pair(s, r));
                      default: return false;
                    }; 
                  //{NA, K(AB), B, {K(AB), A, NB1}_K(BS)}_K(AS)
                  case pair_item(first2, second2): return
                    switch(first1)
                    {
                      case session_key_item(s3, r3, count3, info3): return
                        s3 == s && r3 == r &&
                        //NA
                        switch(first0)
                        {
                          case nonce_item(s4, count4, info4): return
                            s4 == s && info4 == int_pair(2, int_pair(s, r));
                          default: return false;
                        } &&
                        //K(AB)
                        info3 == int_pair(0, 0) &&
                        //B
                        first2 == data_item(r) &&
                        // {K(AB), A, NB1}_K(BS)
                        mypub(second2);
                      default: return false;
                    };
                  default: return false;
                };
              default: return false;
            };
          default: return false;
        };
    case pair_item(first, second): 
      return mypub(first) && mypub(second);
  }
}

@*/

///////////////////////////////////////////////////////////////////////////////
// Protocol implementation ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void sender(int sender, int receiver, struct item * KAS)
  /*@
      requires 
        generated_nonces(sender, ?count) &*& count > 0 &*&
        !bad(0) &*& !bad(sender) &*& !bad(receiver) &*&
        world(mypub) &*& key_item(KAS, sender, 0, 0, int_pair(0,0));
  @*/
  /*@
      ensures 
        generated_nonces(sender, count + 1) &*&
        world(mypub) &*& key_item(KAS, sender, 0, 0, int_pair(0,0));
  @*/
{
  struct item *i1;
  struct item *i2;
  struct item *i3;
  struct item *i4;
  struct item *i5;
  struct item *i6;
  
  struct item *A = create_data_item(sender);
  struct item *B = create_data_item(receiver);
  //@ close nonce_request(sender, int_pair(2, int_pair(sender,receiver)));
  struct item *NA = create_nonce();
  
  // 1. A -> B. A
  net_send(A);
  
  // 2. B -> A. {A, NB1}_K(BS)
  struct item *B_S1 = net_receive();
    
  // 3. A -> S. A, B, NA, {A, NB1}_K(BS)
  i1 = create_pair(NA, B_S1); // (NA, {A, NB1}_K(BS))
  i2 = create_pair(B, i1); // (B, (NA, {A, NB1}_K(BS)))
  i3 = create_pair(A, i2); // (A, B, (NA, {A, NB1}_K(BS))))
  net_send(i3);
  item_free(i1);
  item_free(i2);
  item_free(i3);
  
  // 4. S -> A. {NA, K(AB), B, {K(AB), A, NB1}_K(BS)}_K(AS)
  i1 = net_receive();
  i2 = decrypt(KAS, i1); // (NA, (K(AB), (B, {K(AB), A, NB1}_K(BS))))
  i3 = pair_get_first(i2); // NA
  i4 = pair_get_second(i2); // (K(AB), (B, {K(AB), A, NB1}_K(BS)))
  struct item *KAB = pair_get_first(i4); // K(AB)
  i5 = pair_get_second(i4); // (B, {K(AB), A, NB1}_K(BS))
  i6 = pair_get_first(i5); // B
  struct item *B_S2 = pair_get_second(i5); // {K(AB), A, NB1}_K(BS)
    // check NA
    if (!item_equals(i3, NA)){abort();}
    // check KAB
    //@ close session_key_request(sender, receiver, int_pair(0, 0));
    check_is_session_key(KAB);
    // check B
    if (!item_equals(i6, B)){abort();}
  item_free(i1);
  item_free(i2);
  item_free(i3);
  item_free(i4);
  item_free(i5);
  item_free(i6);
  
  // 5. A -> B. {K(AB), A, NB1}_K(BS)
  net_send(B_S2);
  
  // 6. B -> A. {NB2}_K(AB)
  i1 = net_receive();
  struct item *NB2 = decrypt(KAB, i1); // NB2
    // check NB2
    check_is_nonce(NB2);
  item_free(i1);
  
  // 7. A -> B. {NB2 + 1}_K(AB)
  i1 = increment_nonce(NB2, 4); // NB2 + 1
  i2 = encrypt(KAB, i1); // {NB2 + 1}_K(AB)
  net_send(i2);
  item_free(i1);
  item_free(i2);
  
  item_free(NA);
  item_free(A);
  item_free(B);
  item_free(NB2);
  item_free(B_S1);
  item_free(B_S2);
  //@ open key_item(KAB, _, _, _, _);
  item_free(KAB);
}

void receiver(int receiver, struct item * KBS)
  /*@
      requires 
        generated_nonces(receiver, ?count) &*& count > 0 &*& 
        !bad(0) &*& !bad(receiver) &*&
        world(mypub) &*& key_item(KBS, receiver, 0, 0, ?info);
  @*/
  /*@
      ensures 
        generated_nonces(receiver, count + 2) &*&
        world(mypub) &*& key_item(KBS, receiver, 0, 0, info);
  @*/
{
  struct item *i1;
  struct item *i2;
  struct item *i3;
  struct item *i4;
  struct item *i5;
  
  struct item *B = create_data_item(receiver);
  
  // 1. A -> B. A
  struct item *A = net_receive();
  int sender = item_get_data(A);
  
  // 2. B -> A. {A, NB1}_K(BS)
  //@ close nonce_request(receiver, int_pair(2, int_pair(0, receiver)));
  struct item *NB1 = create_nonce();
  i1 = create_pair(A, NB1); // (A, NB1)
  i2 = encrypt(KBS, i1); // {A, NB1}_K(BS)
  net_send(i2);
  item_free(i1);
  item_free(i2);
  
  // 5. A -> B. {K(AB), A, NB1}_K(BS)
  i1 = net_receive();
  i2 = decrypt(KBS, i1); // (K(AB), (A, NB1))
  struct item *KAB = pair_get_first(i2); // K(AB)
  i3 = pair_get_second(i2); // (A, NB1)
  i4 = pair_get_first(i3); // A
  i5 = pair_get_second(i3); // NB1
    // check KAB
    //@ close session_key_request(sender, receiver, int_pair(0, 0));
    check_is_session_key(KAB);
    //@ assert key_item(KAB, sender, receiver, _, int_pair(0, 0));
    // check A
    if (!item_equals(i4, A)){abort();}
    // check NB1
    if (!item_equals(i5, NB1)){abort();}
  item_free(i1);
  item_free(i2);
  item_free(i3);
  item_free(i4);
  item_free(i5);
  
  // 6. B -> A. {NB2}_K(AB)
  //@ close nonce_request(receiver, int_pair(3, int_pair(sender, receiver)));
  struct item *NB2 = create_nonce();
  i1 = encrypt(KAB, NB2); // {NB2}_K(AB)
  /*@ assert item(i1, encrypted_item(_, receiver, _, _, 
               nonce_item(receiver, _, int_pair(3, int_pair(sender, receiver))), 
             _)); 
  @*/
  net_send(i1);
  item_free(i1);
  
  // 7. A -> B. {NB2 + 1}_K(AB)
  i1 = net_receive();
  struct item *NB2_11 = decrypt(KAB, i1); // NB2 + 1
  struct item *NB2_12 = increment_nonce(NB2, 4);
    // check NB2 + 1
    if (!item_equals(NB2_11, NB2_12)){abort();}
  item_free(i1);
  
  item_free(A);
  item_free(B);
  item_free(NB1);
  item_free(NB2);
  item_free(NB2_11);
  item_free(NB2_12);
  //@ open key_item(KAB, _, _, _, _);
  item_free(KAB);
}

void server()
  /*@
      requires 
        generated_keys(0) &*& world(mypub) &*& !bad(0);
  @*/
  /*@
      ensures 
        generated_keys(0) &*& world(mypub);
  @*/
{
  struct item *i1;
  struct item *i2;
  struct item *i3;
  struct item *i4;
  struct item *i5;
  struct item *i6;
  struct item *i7;
  
  // 3. A -> S. A, B, NA, {A, NB1}_K(BS)
  i1 = net_receive();
  struct item *A = pair_get_first(i1); // A
  int sender = item_get_data(A);
  //@ close server_key_request(int_pair(0, 0));
  struct item *KAS = get_server_key(sender);
  i2 = pair_get_second(i1); // (B, (NA, {A, NB1}_K(BS)))
  struct item *B = pair_get_first(i2); // B
  int receiver = item_get_data(B);
  //@ close server_key_request(int_pair(0, 0));
  struct item *KBS = get_server_key(receiver);
  i3 = pair_get_second(i2); // (NA, {A, NB1}_K(BS))
  struct item *NA = pair_get_first(i3); // NA
  i4 = pair_get_second(i3); // {A, NB1}_K(BS)
  i5 = decrypt(KBS, i4); // (A, NB1)
  i6 = pair_get_first(i5); // A to check
  struct item *NB1 = pair_get_first(i6); // NB1
    // check A
    if (!item_equals(A, i6)){abort();}
  item_free(i1);
  item_free(i2);
  item_free(i3);
  item_free(i4);
  item_free(i5); 
  item_free(i6); 
  
  // 4. S -> A. {NA, K(AB), B, {K(AB), A, NB1}_K(BS)}_K(AS)
  //@ close session_key_request(receiver, 0);
  struct item *KAB = create_session_key(); // KAB
  i1 = create_pair(A, NB1);
  i2 = create_pair(KAB, i1);
  i3 = encrypt(KBS, i2);
  i4 = create_pair(B, i3);
  i5 = create_pair(KAB, i4);
  i6 = create_pair(NA, i5);
  i7 = encrypt(KAS, i6);
  net_send(i6);
  item_free(i1);
  item_free(i2);
  item_free(i3);
  item_free(i4);
  item_free(i5); 
  item_free(i6); 
  item_free(i7); 
  
  item_free(A);
  item_free(B);
  item_free(NB1);
  item_free(NA);
  item_free(KAB);
}

///////////////////////////////////////////////////////////////////////////////
// Attacker representation ////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////    

int choose();
  //@ requires true;
  //@ ensures true;

void attacker()
  //@ requires world(mypub) &*& initial_principals();
  //@ ensures false;
{
  //@ open initial_principals();
  for (;;)
    //@ invariant world(mypub) &*& generated_keys(_) &*& principals(_);
  {
    int action = choose();
    switch (action) 
    {
      case 0:
        // Bad key server leaks server keys...
        int principal = choose();
        //@ assume(bad(0));
        //@ close server_key_request(int_pair(0, 0));
        struct item *key = get_server_key(principal);
        //@ open key_item(key, _, _, _, _);
        net_send(key);
        item_free(key);
        break;
      case 1:
        // Bad key server leaks session keys...
        int sender = choose();
        int receiver = choose();
        //@ assume(bad(0));
        //@ close session_key_request(sender, receiver, int_pair(0, 0));
        struct item *key = create_session_key();
        net_send(key);
        item_free(key);
        break;
      case 2:
        // Attackers are arbitrary principals.
        //@ close create_principal_request(int_pair(0, 0));
        struct item *server_key = create_principal();
        for (;;)
          /*@ 
              invariant world(mypub) &*& principals(_) &*&
                        item(server_key, (server_key_item(?me, int_pair(0, 0)))) &*&
                        generated_nonces(me, 0); 
          @*/
        {
          action = choose();
          switch (action) 
          {
            case 0:
              // Bad principals leaks its server keys...
              //@ assume(bad(me));
              net_send(server_key);
              break;
            case 1:
              // Anyone can publish arbitrary data items...
              int data = choose();
              struct item *item = create_data_item(data);
              net_send(item);
              item_free(item);
              break;
            case 2:
              // Anyone can create pairs of public items...
              struct item *first = net_receive();
              struct item *second = net_receive();
              struct item *pair = create_pair(first, second);
              item_free(first);
              item_free(second);
              net_send(pair);
              item_free(pair);
              break;
            case 3:
              // Anyone can deconstruct a public pair...
              struct item *pair = net_receive();
              struct item *first = pair_get_first(pair);
              struct item *second = pair_get_second(pair);
              item_free(pair);
              net_send(first);
              item_free(first);
              net_send(second);
              item_free(second);
              break;
            case 4:
              // Anyone can encrypt a public item with a published key...
              struct item *key = net_receive();
              struct item *payload = net_receive();
              int sender = choose();
              int receiver = choose();
              //@ close session_key_request(sender, receiver, int_pair(0, 0));
              check_is_session_key(key);
              struct item *item = encrypt(key, payload);
              //@ open key_item(key, _, _, _, _);
              item_free(key);
              item_free(payload);
              net_send(item);
              item_free(item);
              break;
            case 5:
              // Anyone can decrypt a public item with a published key...
              struct item *key = net_receive();
              struct item *package = net_receive();
              int sender = choose();
              int receiver = choose();
              //@ close session_key_request(sender, receiver, int_pair(0, 0));
              check_is_session_key(key);
              struct item *payload = decrypt(key, package);
              //@ assert item(payload, _);
              //@ open key_item(key, sender, receiver, _, int_pair(0,0));
              item_free(key);
              item_free(package);
              //@ assert item(payload, ?p);
              /*@
                  if (mypub(p)) 
                  {
                  } 
                  else 
                  {
                    switch (p) 
                    {
                      case nonce_item(p0, count0, info0): p = p;
                      case server_key_item(s0, info0): p = p;
                      case session_key_item(s0, r0, count0, info0): p = p;
                      case data_item(d0): p = p;
                      case encrypted_item(s0, r0, count0, info0, payload0, entropy0): p = p;
                      case pair_item(first0, second0):
                        p = p;
                        switch (second0) 
                        {
                          // {A, NB1}
                          case nonce_item(s1, count1, info1): 
                            p = p;
                            assert (first0 == data_item(_));
                          case server_key_item(s1, info1): p = p;
                          case session_key_item(s1, r1, count1, info1): p = p;
                          case data_item(d1): p = p;
                          case encrypted_item(s1, r1, count1, info1, payload1, entropy1): p = p;
                          case pair_item(first1, second1):
                            p = p;
                            switch (second1) 
                            {
                              // {K(AB), A, NB1}
                              case nonce_item(s2, count2, info2): 
                                p = p;
                                assert (first0 == session_key_item(sender, receiver, _, _));
                              case server_key_item(s2, info2): p = p;
                              case session_key_item(s2, r2, count2, info2): p = p;
                              case data_item(d2): p = p;
                              case encrypted_item(s2, r2, count2, info2, payload2, entropy2): p = p;
                              // {NA, K(AB), B, {K(AB), A, NB1}
                              case pair_item(first2, second2):
                                p = p;
                                switch (first1)
                                {
                                  case nonce_item(p3, count3, info3): p = p;
                                  case server_key_item(s3, info3): p = p;
                                  case session_key_item(s3, r3, count3, info3):
                                    p = p;
                                    assert (first0 == session_key_item(sender, receiver, _, _));
                                  case data_item(d3): p = p;
                                  case encrypted_item(s3, r3, count3, info3, payload3, entropy3): p = p;
                                  case pair_item(first3, second3): p = p;
                                }
                            }
                       }
                    }
                  }
              @*/
              net_send(payload);
              item_free(payload);
              break;
          }
        }
        break;
    }
  }
}

