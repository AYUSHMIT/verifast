#ifndef DOLEVYAO_H
#define DOLEVYAO_H

#include "bool.h"

/*

Dolev-Yao security verification of security protocols. Uses an invariant-based 
approach inspired by the work of Ernie Cohen and the work of Andrew Gordon et 
al.

Items
=====

Dolev-Yao security of a protocol means that the intended security properties are 
verified under the assumption that the cryptographic primitives used, such as 
key generation, keyed hashes, etc. are perfect. This assumption is formalized by 
modelling items sent over public channels not as bitstrings but as structured 
values.

For example, we represent the Nth key generated by principal P as a structured 
value key_item(P, N, I), where I is some protocol specific info. It 
automatically follows that key_item(P1, N1, I1) == key_item(P2, N2, I2) if and 
only if P1 == P2 and N1 == N2 and I1 == I2. This formalizes the assumption that 
key generation generates unique keys.

We represent the HMAC keyed hash of payload item P generated with the Nth key 
generated by principal P as hmac_item(P, N, I, P), where I is some protocol 
specific info. This formalizes the assumption that there are no hash collisions.

API wrapper functions
=====================

We are verifying real, working protocol implementations. These use real 
cryptographic functions, and real network I/O functions. The data objects 
manipulated by these functions, such as keys, messages, and hashes, are 
bitstrings. However, to facilitate associating an item value with such a 
physical data object, we wrap these functions in a thin layer that represents 
the data objects as objects of type struct item. The wrapper functions are 
specified in terms of a predicate item(item, i) that states that item object 
"item" represents item value "i".

We do not provide an implementation of the wrappers here, but such an 
implementation is straightforward.

Network I/O and "pub"
=====================

We also declare wrappers for network I/O, called net_send and net_receive. For 
simplicity, we ignore addressing aspects: net_send sends an item into the world, 
and net_receive plucks an arbitrary item from the world. The world is where the 
attacker is. We represent the world by a predicate "world(pub)", where "pub" is 
a pure function from item values to booleans; that is, it is a predicate on item 
values. It specifies an upper bound on which item values are sent into the 
world. That is, net_send requires that the item being sent satisfies pub, and 
net_receive ensures that the item that is returned satisfies pub.

In the implementation file of a protocol, there should be two groups of 
functions: the functions that implement the protocol, and the function that 
represents the attacker. Function "attacker" performs all the operations that an 
attacker can perform. Specifically, it generates keys and publishes them; it 
creates hashes of public items and publishes them; it constructs and destructs 
pairs; etc.

Crucially, both groups of functions operate on the same world, with the same 
"pub" function. (This is not checked by VeriFast.)

Verifying protocol integrity
============================

Protocol integrity means that if the protocol implementation reports to the 
application that something has happened, it has indeed happened. For example, in 
the case of an RPC protocol, if the protocol implementation on the server 
reports an incoming request from a given client principal, this client principal 
must in fact have made this request. Analogously, if the client protocol reports 
a response from the server principal, the application at this principal must 
indeed have submitted this response.

This is formalized using "event predicates". Here, I use the term "predicate" 
not in the sense of a VeriFast predicate, but in the sense of a function that 
returns a boolean. Specifically, for each event, an unimplemented fixpoint 
function is declared that takes as arguments the values that identify the event, 
and returns bool.

Note: we do model bad principals. That is, we declare a function bad(P) that 
returns true if P is bad and false if it is not. The integrity of the protocol 
is conditional on the client and server not being bad. That is, integrity means 
that "good" principals can use the protocol safely, even if other principals 
that are using the protocol are bad. Badness of principal P in this example 
means that P publishes keys that it creates. Conversely, if P is not bad, it 
does not publish keys that it creates.

Defining "pub"
==============

The core task of verifying a protocol implementation is defining "pub". "pub" 
must be sufficiently weak so that sends by the protocol functions and sends by 
the attacker are allowed; but sufficiently strong so that when the protocol 
receives an item and the item is valid, the appropriate event predicate follows 
from it.

*/

//@ #include "switch_primitives.gh"

///////////////////////////////////////////////////////////////////////////////
// Initialization /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void init_crypto_lib();
  //@ requires exists<fixpoint(item, bool)>(?pub) &*& net_api_uninitialized();
  //@ ensures world(pub);

///////////////////////////////////////////////////////////////////////////////
// General definitions ////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*@ 

predicate world(fixpoint(item, bool) pub);
fixpoint bool bad(int principal);

fixpoint int int_left(int p);
fixpoint int int_right(int p);
fixpoint int int_pair(int f, int s);

lemma_auto void int_left_int_pair(int f, int s);
  requires true;
  ensures  int_left(int_pair(f, s)) == f;

lemma_auto void int_right_int_pair(int f, int s);
  requires true;
  ensures  int_right(int_pair(f, s)) == s;

@*/

int choose();
    //@ requires true;
    //@ ensures true;

///////////////////////////////////////////////////////////////////////////////
// Item definitions ///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct item;

/*@

inductive key_kind =
  | symmetric_key
  | public_key
  | private_key;

inductive item =
  | nonce_item(int principal, int count, int info)
  | key_item(int principal, int count, key_kind kind, int info)
  | data_item(int data)
  | hmac_item(int principal, int count, key_kind kind, int info, item payload)
  | encrypted_item(int principal, int count, key_kind kind, int info, item payload, int entropy)
  | pair_item(item first, item second);
  
predicate item(struct item *item, item i);

@*/

bool item_equals(struct item *item1, struct item *item2);
  //@ requires item(item1, ?i1) &*& item(item2, ?i2);
  //@ ensures  item(item1, i1) &*& item(item2, i2) &*& result == (i1 == i2);

struct item *item_clone(struct item *item);
  //@ requires item(item, ?i);
  //@ ensures  item(item, i) &*& item(result, i);

void item_free(struct item *item);
  //@ requires item(item, _);
  //@ ensures  true;

///////////////////////////////////////////////////////////////////////////////
// Principals /////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*@

// Keeps track of the number of principals generated, so as to ensure unique principal ids
predicate principals(int count);

// Keeps track of the number of nonces generated by principal
predicate generated_nonces(int principal, int count);

// Keeps track of the number of keys generated by principal
predicate generated_keys(int principal, int count);

@*/

///////////////////////////////////////////////////////////////////////////////
// Nonce item /////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//@ predicate nonce_request(int principal, int info) = emp;

struct item *create_nonce();
  /*@ requires generated_nonces(?principal, ?count) &*& 
               nonce_request(principal, ?info); 
  @*/
  /*@ ensures  generated_nonces(principal, count + 1) &*&
               item(result, nonce_item(principal, count, info)); 
  @*/

struct item *increment_nonce(struct item *item, int amount);
  //@ requires item(item, nonce_item(?principal, ?count, ?info));
  /*@ ensures  item(item, nonce_item(principal, count, info)) &*& 
               item(result, nonce_item(principal, count, int_pair(amount, info))); @*/

// check_is_nonce aborts if the item is not a nonce
void check_is_nonce(struct item *item);
  //@ requires item(item, ?i);
  /*@ ensures
        switch (i) 
        {
          case nonce_item(p0, c0, i0): 
            return item(item, nonce_item(p0, c0, i0));
          case key_item(p0, c0, k0, i0): return false;
          case data_item(d0): return false;
          case hmac_item(p0, c0, k0, i0, payload0): return false;
          case encrypted_item(p0, c0, k0, i0, payload0, entropy0): return false;
          case pair_item(f0, s0): return false;
        }; 
  @*/

///////////////////////////////////////////////////////////////////////////////
// Key item ///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*@
predicate key_item(struct item *item, int participant, int count, key_kind kind, int info) =
    item(item, key_item(participant, count, kind, info));
@*/

//Symmetric keys

//@ predicate key_request(int principal, int info) = emp;

struct item *create_key();
  /*@ requires key_request(?principal, ?info) &*&
               generated_keys(principal, ?count); 
  @*/
  /*@ ensures  generated_keys(principal, count + 1) &*& 
               key_item(result, principal, count, symmetric_key, info); 
  @*/

struct item *key_clone(struct item* key);
  //@ requires key_item(key, ?principal, ?count, ?kind, ?info); 
  /*@ ensures  key_item(key, principal, count, kind, info) &*&
               key_item(result, principal, count, kind, info); 
  @*/

void key_free(struct item* key);
  //@ requires key_item(key, _, _, _, _);
  //@ ensures  true;

//check_is_key aborts if the item is not a key.
void check_is_key(struct item *item);
  //@ requires item(item, ?i);
  /*@ ensures
        switch (i) 
        {
          case nonce_item(p0, c0, i0): return false;
          case key_item(p0, c0, k0, i0):
            return key_item(item, p0, c0, k0, i0);
          case data_item(d0): return false;
          case hmac_item(p0, c0, k0, i0, payload0): return false;
          case encrypted_item(p0, c0, k0, i0, payload0, entropy0): return false;
          case pair_item(f0, s0): return false;
       }; 
  @*/

//Asymmetric keys

struct keypair; 
//@ predicate keypair(struct keypair *keypair, int creator, int id, int info);
//@ predicate keypair_request(int info) = emp;
//@ predicate public_key_request(int info) = emp;

struct keypair *create_keypair(int principal);
    //@ requires keypair_request(?info) &*& generated_keys(principal, ?count);
    /*@ ensures generated_keys(principal, count + 1) &*& 
                keypair(result, principal, count, info);
    @*/

struct item *get_public_key(int participant);
  //@ requires public_key_request(?info);
  //@ ensures key_item(result, participant, _, public_key, info);
  
void keypair_free(struct keypair *keypair);
    //@ requires keypair(?result, ?principal, ?count, ?info);
    //@ ensures true;

struct item *keypair_get_private_key(struct keypair *keypair);
    //@ requires keypair(keypair, ?creator, ?id, ?info);
    /*@ ensures keypair(keypair, creator, id, info) &*& 
        key_item(result, creator, id, private_key, info);
    @*/

struct item *keypair_get_public_key(struct keypair *keypair);
    //@ requires keypair(keypair, ?creator, ?id, ?info);
    //@ ensures key_item(result, creator, id, public_key, info);

///////////////////////////////////////////////////////////////////////////////
// Data item //////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct item *create_data_item(int data);
  //@ requires true;
  //@ ensures  item(result, data_item(data));

// item_get_data aborts if the item is not a data item.
int item_get_data(struct item *item);
  //@ requires item(item, ?i);
  /*@ ensures
        switch (i) 
        {
          case nonce_item(p0, c0, i0): return false;
          case key_item(p0, c0, k0, i0): return false;
          case data_item(d0):
            return item(item, i) &*& result == d0;
          case hmac_item(p0, c0, k0, i0, payload0): return false;
          case encrypted_item(p0, c0, k0, i0, payload0, entropy0): return false;
          case pair_item(f0, s0): return false;
        };  
  @*/

///////////////////////////////////////////////////////////////////////////////
// Hmac item //////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct item *hmac(struct item *key, struct item *payload);
  //@ requires key_item(key, ?creator, ?id, ?kind, ?info) &*& item(payload, ?p);
  /*@ ensures  key_item(key, creator, id, kind, info) &*& item(payload, p) &*& 
               item(result, hmac_item(creator, id, kind, info, p)); @*/

void hmacsha1_verify(struct item *hash, struct item *key, struct item *payload);
  /*@ requires item(hash, ?h) &*& key_item(key, ?creator, ?id, ?kind, ?info) &*& 
               item(payload, ?p); 
  @*/
  /*@ ensures  item(hash, h) &*& key_item(key, creator, id, kind, info) &*& 
               item(payload, p) &*& h == hmac_item(creator, id, kind, info, p); 
  @*/

//check_is_hmac aborts if the item is not a hmac.
void check_is_hmac(struct item *item);
  //@ requires item(item, ?i);
  /*@ ensures
        switch (i) 
        {
          case nonce_item(p0, c0, i0): return false;
          case key_item(p0, c0, k0, i0): return false;
          case data_item(d0): return false;
          case hmac_item(p0, c0, k0, i0, payload0):
            return item(item, hmac_item(p0, c0, k0, i0, payload0));
          case encrypted_item(p0, c0, k0, i0, payload0, entropy0): return false;
          case pair_item(f0, s0): return false;
       }; 
  @*/

///////////////////////////////////////////////////////////////////////////////
// Encrypted item /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*@ 
predicate entropy(int value) = true;

fixpoint key_kind inverse_key_kind(key_kind k)
{
  switch(k)
  {
    case symmetric_key: return symmetric_key;
    case public_key: return private_key;
    case private_key: return public_key;
  }
}

@*/

// This function aborts if the key is not a key item.
struct item *encrypt(struct item *key, struct item *payload);
  /*@ requires key_item(key, ?s, ?count, ?kind, ?info) &*& item(payload, ?p); @*/
  /*@ ensures  key_item(key, s, count, kind, info) &*& 
        (kind == symmetric_key || kind == public_key) &*&
        item(payload, p) &*& [_]entropy(?entropy) &*& 
        item(result, encrypted_item(s, count, kind, info, p, entropy));
  @*/

// This function aborts if key is not a key item or if it is not a correct key.
struct item *decrypt(struct item *key, struct item *item);
  /*@ requires key_item(key, ?participant, ?count, ?kind, ?info) &*& 
               item(item, ?i); @*/
  /*@ ensures  key_item(key, participant, count, kind, info) &*& item(item, i) &*&
        (kind == symmetric_key || kind == private_key) &*&
        switch (i) 
        {
          case nonce_item(p0, c0, i0): return false;
          case key_item(p0, c0, k0, i0): return false;
          case data_item(d0): return false;
          case hmac_item(p0, c0, k0, i0, payload0): return false;
          case encrypted_item(p0, c0, k0, i0, payload0, entropy0): return
            k0 == inverse_key_kind(kind) &*&
            p0 == participant &*& c0 == count &*& 
            i0 == info &*& item(result, payload0);
          case pair_item(f0, s0): return false;
        };
  @*/

///////////////////////////////////////////////////////////////////////////////
// Pair item //////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct item *create_pair(struct item *first, struct item *second);
  //@ requires item(first, ?f) &*& item(second, ?s);
  //@ ensures item(first, f) &*& item(second, s) &*& item(result, pair_item(f, s));

// This function aborts if the pair is not a pair item.
struct item *pair_get_first(struct item *pair);
  //@ requires item(pair, ?p);
  /*@ ensures  item(pair, p) &*&
        switch (p) 
        {
          case nonce_item(p0, c0, i0): return false;
          case key_item(p0, c0, k0, i0): return false;
          case data_item(d0): return false;
          case hmac_item(p0, c0, k0, i0, payload0): return false;
          case encrypted_item(p0, c0, k0, i0, payload0, entropy0): return false;
          case pair_item(f0, s0):
            return item(result, f0);
        };
  @*/

// This function aborts if the pair is not a pair item.
struct item *pair_get_second(struct item *pair);
  //@ requires item(pair, ?p);
  /*@ ensures  item(pair, p) &*&
        switch (p) 
        {
          case nonce_item(p0, c0, i0): return false;
          case key_item(p0, c0, k0, i0): return false;
          case data_item(d0): return false;
          case hmac_item(p0, c0, i0, k0, payload0): return false;
          case encrypted_item(p0, c0, k0, i0, payload0, entropy0): return false;
          case pair_item(f0, s0):
            return item(result, s0);
        };
  @*/

struct item *get_client_public_key(int participant);
  //@ requires public_key_request(?info);
  //@ ensures key_item(result, participant, _, public_key, info);

///////////////////////////////////////////////////////////////////////////////
// Network ////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

struct network_status;

//@ predicate net_api_uninitialized();

struct network_status *network_bind(int port);
  //@ requires true;
  //@ ensures true;

struct network_status *network_connect(const char *name, int port);
  //@ requires true;
  //@ ensures true;

void network_disconnect(struct network_status *stat);
  //@ requires true;
  //@ ensures true;

void network_send(struct network_status *stat, struct item *datagram);
  //@ requires [?f]world(?pub) &*& item(datagram, ?d) &*& pub(d) == true;
  //@ ensures [f]world(pub) &*& item(datagram, d);

struct item *network_receive(struct network_status *stat);
  //@ requires [?f]world(?pub);
  //@ ensures [f]world(pub) &*& item(result, ?d) &*& pub(d) == true;

struct item *network_receive_attempt(struct network_status *stat);
  //@ requires [?f]world(?pub);
  /*@ ensures [f]world(pub) &*&
              result == 0 ? true : item(result, ?d) &*& pub(d) == true;
  @*/

///////////////////////////////////////////////////////////////////////////////
// Attacker capabilities //////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//Participant 0 is a trusted server, which whom everyone shares a set of keys
/*@ predicate initial_principals() = 
      principals(?count) &*& count > 0 &*& bad(0) == false; @*/

int create_principal(struct item **key_sym_pp, struct keypair **key_pair_pp);
  /*@ requires *key_sym_pp |-> _ &*& *key_pair_pp |-> _ &*&
               principals(?count);
  @*/
  /*@ ensures  principals(count + 1) &*& 
               result == count &*&
               generated_nonces(count, 0) &*&
               generated_keys(count, 0) &*&
               *key_sym_pp |-> ?key_sym &*& *key_pair_pp |-> ?key_pair &*&
               key_item(key_sym, count, 0, symmetric_key, int_pair(0, 0)) &*&
               keypair(key_pair, count, 0, int_pair(0, 0));
  @*/
  
///////////////////////////////////////////////////////////////////////////////
// Switch template ////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// //@ assert item(item, ?i) &*&
// /*@ switch (i) 
//     {
//       case nonce_item(p0, c0, ii0): i = i;
//       case key_item(p0, c0, k0, ii0): i = i;
//       case data_item(d0): i = i;
//       case hmac_item(p0, c0, ii0, payload0): i = i;
//       case encrypted_item(p0, c0, k0, ii0, payload0, entropy0): i = i;
//       case pair_item(f0, s0): i = i;
//     }
// @*/

#endif
