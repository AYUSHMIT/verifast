#ifndef ATTACKER_PROOF_OBLIGATIONS_H
#define ATTACKER_PROOF_OBLIGATIONS_H

#define PACK_ATTACKER_PROOF_OBLIGATIONS(PREFIX) \
{ \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_bad_principal_keys) : \
    can_send_bad_principal_keys(PREFIX##_pub)(PREFIX##_p){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_data) : \
    can_send_data(PREFIX##_pub)(PREFIX##_data){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_public_pair) : \
    can_send_public_pair(PREFIX##_pub)(){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_decomposed_public_pair) : \
    can_send_decomposed_public_pair(PREFIX##_pub)(PREFIX##_pair){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_public_encrypted) : \
    can_send_public_encrypted(PREFIX##_pub)(PREFIX##_key){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_public_decrypted) : \
    can_send_public_decrypted(PREFIX##_pub)(PREFIX##_key, PREFIX##_encrypted){ call(); }; \
  produce_lemma_function_pointer_chunk(PREFIX##_can_send_public_hmac) : \
    can_send_public_hmac(PREFIX##_pub)(PREFIX##_key){ call(); }; \
}

#define ATTACKER_PROOFS_DEFAULT(PREFIX) \
  DEFAULT_CAN_SEND_BAD_PRINCIPAL_KEYS(PREFIX) \
  DEFAULT_CAN_SEND_DATA(PREFIX) \
  DEFAULT_CAN_SEND_PUBLIC_PAIR(PREFIX) \
  DEFAULT_CAN_SEND_DECOMPOSED_PUBLIC_PAIR(PREFIX) \
  DEFAULT_CAN_SEND_PUBLIC_ENCRYPTED(PREFIX) \
  DEFAULT_CAN_SEND_PUBLIC_DECRYPTED(PREFIX) \
  DEFAULT_CAN_SEND_PUBLIC_HMAC(PREFIX)

#define DEFAULT_CAN_SEND_BAD_PRINCIPAL_KEYS(PREFIX) \
lemma void PREFIX##_can_send_bad_principal_keys(int p) \
  requires [?f0]world(PREFIX##_pub) &*& \
           item(?item, key_item(p, ?c, ?k, ?i)) &*& \
           bad(p) == true; \
  ensures  [f0]world(PREFIX##_pub) &*& \
           item(item, key_item(p, c, k, i)) &*& \
           PREFIX##_pub(key_item(p, c, k, i)) == true; \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_DATA(PREFIX) \
lemma void PREFIX##_can_send_data(int data) \
  requires [?f0]world(PREFIX##_pub); \
  ensures  [f0]world(PREFIX##_pub) &*& \
           PREFIX##_pub(data_item(data)) == true; \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_PUBLIC_PAIR(PREFIX) \
lemma void PREFIX##_can_send_public_pair() \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(?i1, ?ii1) &*& PREFIX##_pub(ii1) == true &*& \
            item(?i2, ?ii2) &*& PREFIX##_pub(ii2) == true; \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(i1, ii1) &*& \
            item(i2, ii2) &*& \
            PREFIX##_pub(pair_item(ii1, ii2)) == true; \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_DECOMPOSED_PUBLIC_PAIR(PREFIX) \
lemma void PREFIX##_can_send_decomposed_public_pair(struct item* pair) \
   requires  [?f0]world(PREFIX##_pub) &*& \
            item(?i, pair_item(?i1, ?i2)) &*& \
            PREFIX##_pub(pair_item(i1, i2)) == true; \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(i, pair_item(i1, i2)) &*& \
            PREFIX##_pub(i1) == true &*& PREFIX##_pub(i2) == true; \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_PUBLIC_ENCRYPTED(PREFIX) \
lemma void PREFIX##_can_send_public_encrypted(struct item* key) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(?k_item, key_item(?p, ?c, ?k, ?i)) &*& \
            PREFIX##_pub(key_item(p, c, k, i)) == true &*& \
            item(?p_item, ?payload) &*& \
            PREFIX##_pub(payload) == true &*& \
            item(?e_item, encrypted_item(p, c, k, i, payload, ?e)); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(k_item, key_item(p, c, k, i)) &*& \
            item(p_item, payload) &*& \
            item(e_item, encrypted_item(p, c, k, i, payload, e)) &*& \
            PREFIX##_pub(encrypted_item(p, c, k, i, payload, e)) == true; \
{ \
  assert true; \
}

#define DEFAULT_CAN_SEND_PUBLIC_DECRYPTED(PREFIX) \
  DEPTH_CAN_SEND_PUBLIC_DECRYPTED(PREFIX, 1)

#define DEPTH_CAN_SEND_PUBLIC_DECRYPTED(PREFIX, DEPTH) \
lemma void PREFIX##_can_send_public_decrypted(struct item* key, struct item* encrypted) \
  requires  [?f0]world(PREFIX##_pub) &*&  \
            item(?k_item, key_item(?p, ?c, ?k, ?i)) &*& \
            PREFIX##_pub(key_item(p, c, k, i)) == true &*& \
            bad(0) == false &*& \
            item(?e_item, encrypted_item(p, c, inverse_key_kind(k), i, ?payload, ?e)) &*& \
            PREFIX##_pub(encrypted_item(p, c, inverse_key_kind(k), i, payload, e)) == true &*& \
            item(?p_item, payload); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(k_item, key_item(p, c, k, i)) &*& \
            item(p_item, payload) &*& \
            item(e_item, encrypted_item(p, c, inverse_key_kind(k), i, payload, e)) &*& \
            PREFIX##_pub(payload) == true; \
{ \
  SWITCH_CRYPTO_PRIMITIVES(p_item, 1, DEPTH); \
}

#define DEFAULT_CAN_SEND_PUBLIC_HMAC(PREFIX) \
lemma void PREFIX##_can_send_public_hmac(struct item* key) \
  requires  [?f0]world(PREFIX##_pub) &*& \
            item(?k_item, key_item(?p, ?c, ?k, ?i)) &*& \
            PREFIX##_pub(key_item(p, c, k, i)) == true &*& \
            item(?p_item, ?payload) &*& \
            PREFIX##_pub(payload) == true &*& \
            item(?h_item, hmac_item(p, c, k, i, payload)); \
  ensures   [f0]world(PREFIX##_pub) &*& \
            item(k_item, key_item(p, c, k, i)) &*& \
            item(p_item, payload) &*& \
            item(h_item, hmac_item(p, c, k, i, payload)) &*& \
            PREFIX##_pub(hmac_item(p, c, k, i, payload)) == true; \
{ \
  assert true; \
}

#endif
