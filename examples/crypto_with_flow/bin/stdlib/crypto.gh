#ifndef CRYPTO_GH
#define CRYPTO_GH

#define MINIMAL_STRING_SIZE 10

predicate principal(int principal, int generated_values);

//is true if a cryptographic collision occurs in a protocol run
fixpoint bool col();

inductive crypto_chars_kind =
  | normal
  | secret
  | garbage
;

predicate crypto_chars(crypto_chars_kind kind,
                       char *array, int n; list<char> cs);

lemma_auto void crypto_chars_to_chars(char *array, int n);
  requires [?f]crypto_chars(?kind, array, n, ?cs) &*& col || kind == normal;
  ensures  [f]chars(array, n, cs);

lemma_auto void chars_to_crypto_chars(char *array, int n);
  requires [?f]chars(array, n, ?cs);
  ensures  [f]crypto_chars(normal, array, n, cs);

lemma_auto void chars_to_secret_crypto_chars(char *array, int n);
  requires [?f]chars(array, n, ?cs);
  ensures  [f]crypto_chars(secret, array, n, cs);

lemma_auto void crypto_chars_inv();
  requires [?f]crypto_chars(?kind, ?array, ?count, ?cs);
  ensures  [f]crypto_chars(kind, array, count, cs) &*& length(cs) == count;

lemma_auto void crypto_chars_limits(char *array);
  requires [?f]crypto_chars(?kind, array, ?n, ?cs) &*&
           true == ((char *)0 <= array) &*& array <= (char *)UINTPTR_MAX;
  ensures  [f]crypto_chars(kind, array, n, cs) &*&
           true == ((char *)0 <= array) &*& array + n <= (char *)UINTPTR_MAX;

lemma void crypto_chars_split(char *array, int offset);
  requires [?f]crypto_chars(?kind, array, ?n, ?cs) &*&
           0 <= offset &*& offset <= n;
  ensures  [f]crypto_chars(kind, array, offset, ?cs1) &*&
           [f]crypto_chars(kind, array + offset, n - offset, ?cs2) &*&
           cs1 == take(offset, cs) &*& cs2 == drop(offset, cs) &*&
           cs == append(cs1, cs2);

lemma_auto void crypto_chars_join(char *array);
  requires [?f]crypto_chars(?kind, array, ?n, ?cs) &*&
           [f]crypto_chars(kind, array + n, ?n0, ?cs0);
  ensures  [f]crypto_chars(kind, array, n + n0, append(cs, cs0));

fixpoint crypto_chars_kind memcmp_kinds_equal_size(crypto_chars_kind kind1,
                                                   crypto_chars_kind kind2)
{
  return kind1 == normal || kind2 == normal ?
           normal
       : kind1 == secret || kind2 == secret ?
           secret
       :
           garbage;  
}

fixpoint crypto_chars_kind memcmp_kinds_nequal_size(crypto_chars_kind kind1,
                                                    crypto_chars_kind kind2)
{
  return kind1 == normal && kind2 == normal ?
           normal
       : kind1 == normal || kind1 == secret || 
         kind2 == normal || kind2 == secret ?
           secret
       :
           garbage;  
}

fixpoint crypto_chars_kind memcmp_kinds(crypto_chars_kind kind1, int size1,
                                        crypto_chars_kind kind2, int size2)
{
  return size1 == size2 ?
           memcmp_kinds_equal_size(kind1, kind2)
         :
           memcmp_kinds_nequal_size(kind1, kind2);
}

#endif
