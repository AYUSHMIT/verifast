#ifndef CRYPTOGRAM_GH
#define CRYPTOGRAM_GH

#include <crypto.gh>

#include "collision.gh"

//The exact set (as a list) of cryptograms exposed by a list of characters
fixpoint list<cryptogram> cgs_in_chars(list<char> cs);

//Associated information of a cryptogram
fixpoint int cg_info(cryptogram cg);

fixpoint bool cg_is_nested(cryptogram cg)
{
  switch(cg)
  {
    case cg_random(p1, c1):        return false;
    case cg_symmetric_key(p1, c1): return false;
    case cg_public_key(p1, c1):    return false;
    case cg_private_key(p1, c1):   return false;
    default: return true;
  }
}

fixpoint list<char> cg_payload(cryptogram cg)
{
  switch(cg)
  {
    case cg_hash(cs1):                               return cs1;
    case cg_hmac(p1, c1, cs1):                       return cs1;
    case cg_encrypted(p1, c1, cs1, ent1):            return cs1;
    case cg_auth_encrypted(p1, c1, mac1, cs1, ent1): return cs1;
    case cg_asym_encrypted(p1, c1, cs1, ent1):       return cs1;
    case cg_asym_signature(p1, c1, cs1, ent1):       return cs1;
    default: return nil;
  }
}

lemma_auto void cg_constraints(cryptogram cg);
     requires true;
     ensures  cons(cg, nil) == cgs_in_chars(chars_for_cg(cg));

lemma void chars_for_cg_inj_random(cryptogram cg1, cryptogram cg2);
  requires cg1 == cg_random(_, _) &*& cg2 == cg_random(_, _) &*&
           chars_for_cg(cg1) == chars_for_cg(cg2);
  ensures  collision_in_run() || cg1 == cg2;

lemma void chars_for_cg_inj_hash(cryptogram cg1, cryptogram cg2);
  requires cg1 == cg_hash(_) &*& cg2 == cg_hash(_) &*&
           chars_for_cg(cg1) == chars_for_cg(cg2);
  ensures  collision_in_run() || cg1 == cg2;

lemma void chars_for_cg_inj_hmac(cryptogram cg1, cryptogram cg2);
  requires cg1 == cg_hmac(?p, ?c, _) &*& cg2 == cg_hmac(p, c, _) &*&
           chars_for_cg(cg1) == chars_for_cg(cg2);
  ensures  collision_in_run() || cg1 == cg2;

lemma void chars_for_cg_inj_encrypted(cryptogram cg1, cryptogram cg2);
  requires cg1 == cg_encrypted(?p, ?c, _, ?ent) &*&
           cg2 == cg_encrypted(p, c, _, ent) &*&
           chars_for_cg(cg1) == chars_for_cg(cg2);
  ensures  collision_in_run() || cg1 == cg2;

lemma cryptogram chars_for_cg_sur_random(list<char> cs);
  requires true;
  ensures  result == cg_random(_, _) &*&
           cs == chars_for_cg(result);

lemma cryptogram chars_for_cg_sur_symmetric_key(list<char> cs);
  requires true;
  ensures  result == cg_symmetric_key(_, _) &*&
           cs == chars_for_cg(result);

lemma cryptogram chars_for_cg_sur_public_key(list<char> cs);
  requires true;
  ensures  result == cg_public_key(_, _) &*&
           cs == chars_for_cg(result);

lemma cryptogram chars_for_cg_sur_private_key(list<char> cs);
  requires true;
  ensures  result == cg_private_key(_, _) &*&
           cs == chars_for_cg(result);

#endif
