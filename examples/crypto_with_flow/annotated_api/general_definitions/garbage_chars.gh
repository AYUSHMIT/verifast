#ifndef RANDOM_CRYPTO_CHARS_GH
#define RANDOM_CRYPTO_CHARS_GH

#include <crypto.gh>

#include "principals.gh"
#include "cryptogram.gh"

// Required by attacker to send the result of a decryption with the wrong key
lemma void bad_garbage_crypto_chars(char *array, int n, list<char> cs);
  requires principal(?id, ?count) &*& true == bad(id) &*&
           [?f]crypto_chars(garbage, array, n, cs);
  ensures  principal(id, count) &*&
           [f]chars(array, n, cs);

// For honest principals, garbage crypto_chars chunks can only be converted to 
// normal chars chunks with the lemma crypto_chars_to_chars if a collision is 
// forced.
//           
// One way to force a collision is to prove that one knows the structure of
// a garbage crypto_chars chunk, thus proving that the correct key was used for 
// decryption (assuming that faulty decryption produces a random result)

fixpoint bool decrypted_garbage(list<char> payload);

inductive structure =
  | known_value(real f, crypto_chars_kind kind, char *array, int n, 
                list<char> known_cs)
  | plaintext_of_incl_one_way_value
  | plaintext_of_excl_one_way_value(real f, crypto_chars_kind kind, 
                                    char *array, int n)
  | cryptogram_with_structured_payload(structure s)
;

#define HAS_STRUCTURE_PAYLOAD_CG \
  exists(?cg) &*& cg_payload(cg) == some(?cs_pay) &*& \
  length(chars_for_cg(cg)) >= MINIMAL_STRING_SIZE &*& \
  length(cs_pay) >= MINIMAL_STRING_SIZE

predicate has_structure(list<char> cs, structure s) =
  exists(pair(?prefix, ?suffix)) &*&
  switch(s) 
  {
    //  ____________ ___________
    // |            |           |
    // |  known_cs  |  rest_cs  |
    // |____________|___________|
    case known_value(f, kind, array, n, known_cs):
      return [f]crypto_chars(kind, array, n, known_cs) &*&
             n >= MINIMAL_STRING_SIZE &*& kind != garbage &*&
             cs == append(prefix, append(known_cs, suffix));
    //  ________________________
    // |            |           |          
    // |     cs     |   F(cs)   |
    // |____________|___________|
    case plaintext_of_incl_one_way_value:
      return HAS_STRUCTURE_PAYLOAD_CG &*& 
             cs == append(prefix, append(chars_for_cg(cg), suffix)) &*&
             cs_pay == append(prefix, suffix);
    //  ________________________     //     ____________
    // |                        |    //    ||||||||||||||
    // |            cs          |    //    ||| F(cs) ||||
    // |________________________|    //    ||||||||||||||
    case plaintext_of_excl_one_way_value(f, kind, array, n):
      return HAS_STRUCTURE_PAYLOAD_CG &*&
             [f]crypto_chars(kind, array, n, chars_for_cg(cg)) &*& 
             n >= MINIMAL_STRING_SIZE &*& kind != garbage &*&
             cs_pay == cs; 
    //  ________________________ 
    // |         |  structured  |
    // |         |______________|
    // |________________________|
    case cryptogram_with_structured_payload(s0):
      return HAS_STRUCTURE_PAYLOAD_CG &*& 
             cs == append(prefix, append(chars_for_cg(cg), suffix)) &*&
             has_structure(cs_pay, s0);
  }
;

lemma void known_garbage_collision(char *array, int n, structure s);
  requires [?f1]crypto_chars(garbage, array, n, ?cs) &*&
           has_structure(cs, s) &*& true == decrypted_garbage(cs);
  ensures  [f1]crypto_chars(garbage, array, n, cs) &*&
           has_structure(cs, s) &*& true == col;

#endif
