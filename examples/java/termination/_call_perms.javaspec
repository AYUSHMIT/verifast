/*@

fixpoint boolean exists<t>(list<t> xs, fixpoint(t, boolean) p) {
    switch (xs) {
        case nil: return false;
        case cons(x, xs0): return p(x) || exists(xs0, p);
    }
}

fixpoint boolean lt_some<t>(fixpoint(t, t, boolean) lt, list<t> ys, t x) {
    return exists(ys, (lt)(x));
}

fixpoint boolean all_lt_some<t>(fixpoint(t, t, boolean) lt, list<t> xs, list<t> ys) {
    return forall(xs, (lt_some)(lt, ys));
}

fixpoint boolean bag_le<t>(fixpoint(t, t, boolean) lt, list<t> xs, list<t> ys) {
    return ys == xs || all_lt_some(lt, remove_all(ys, xs), remove_all(xs, ys)) == true;
}

fixpoint boolean bag_lt<t>(fixpoint(t, t, boolean) lt, list<t> xs, list<t> ys) {
    return bag_le(lt, xs, ys) && remove_all(xs, ys) != nil;
}

fixpoint boolean level_le(list<Class> level1, list<Class> level2) { return bag_le(Class_lt, level1, level2); }

fixpoint boolean level_lt(list<Class> level1, list<Class> level2) { return bag_lt(Class_lt, level1, level2); }

lemma_auto void level_le_cons0(Class c, list<Class> cs)
    requires true;
    ensures level_le({c}, cons(c, cs)) == true;
{ assume(false); }

lemma void level_cons_mono(Class c, list<Class> level1, list<Class> level2)
    requires level_le(level1, level2) == true;
    ensures level_le(cons(c, level1), cons(c, level2)) == true;
{ assume(false); }

lemma void level_cons_mono_l(Class c1, Class c2, list<Class> level)
    requires Class_lt(c1, c2) == true;
    ensures level_lt(cons(c1, level), cons(c2, level)) == true;
{ assume(false); }

lemma void level_le_trans(list<Class> level1, list<Class> level2, list<Class> level3)
    requires level_le(level1, level2) && level_le(level2, level3);
    ensures level_le(level1, level3) == true;
{ assume(false); }

fixpoint list<Class> level_max(list<Class> level1, list<Class> level2);

// Note that if level1 and level2 are equivalent but not equal (i.e. they are permutations) then level_max picks its second argument, not its first.

lemma void level_max_def(list<Class> level1, list<Class> level2)
    requires true;
    ensures level_max(level1, level2) == (level_le(level1, level2) ? level2 : level1);
{ assume(false); }

lemma_auto(level_max(level1, level2)) void level_le_max(list<Class> level1, list<Class> level2)
    requires true;
    ensures level_le(level1, level_max(level1, level2)) && level_le(level2, level_max(level1, level2));
{ assume(false); }

lemma void level_max_le(list<Class> level1, list<Class> level2, list<Class> level3)
    requires level_le(level1, level3) && level_le(level2, level3);
    ensures level_le(level_max(level1, level2), level3) == true;
{ assume(false); }

lemma_auto(level_max(level, level)) void level_max_same(list<Class> level)
    requires true;
    ensures level_max(level, level) == level;
{ assume(false); }

lemma void level_le_append_l(list<Class> level1, list<Class> level2)
    requires true;
    ensures level_le(level1, append(level1, level2)) == true;
{ assume(false); }
    
lemma void level_le_append_r(list<Class> level1, list<Class> level2)
    requires true;
    ensures level_le(level2, append(level1, level2)) == true;
{ assume(false); }

lemma void level_append_mono_l(list<Class> level1, list<Class> level2, list<Class> level3)
    requires level_le(level1, level2) == true;
    ensures level_le(append(level1, level3), append(level2, level3)) == true;
{ assume(false); }

predicate call_perm(list<Class> level);

lemma void call_perm_weaken_and_dup(real frac)
    requires call_perm(cons(_, ?level)) &*& 0 < frac;
    ensures [frac]call_perm(level);
{ assume(false); }

lemma void call_perm_weaken(real frac, list<Class> level)
    requires [frac]call_perm(?level0) &*& level_le(level, level0) == true;
    ensures [frac]call_perm(level);
{ assume(false); }

lemma void consume_call_perm_for(Class c)
    requires call_perm(?level) &*& level_le({c}, level) == true;
    ensures call_perm_(c);
{
    assume(false);
}

lemma void call_below_perm__elim(real frac, list<Class> level)
    requires call_below_perm_(?c) &*& level_lt(level, {c}) == true &*& 0 < frac;
    ensures [frac]call_perm(level);
{ assume(false); }

@*/
