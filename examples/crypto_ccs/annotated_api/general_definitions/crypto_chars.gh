#ifndef CRYPTO_CHARS_GH
#define CRYPTO_CHARS_GH

#include <crypto.gh>
#include "auxiliary_definitions.gh"

lemma void cs_to_ccs_split(list<char> xs, list<char> ys);
  requires true;
  ensures append(cs_to_ccs(xs), cs_to_ccs(ys)) ==
          cs_to_ccs(append(xs, ys));

lemma void cs_to_ccs_take(int n, list<char> xs);
  requires true;
  ensures cs_to_ccs(take(n, xs)) == take(n, cs_to_ccs(xs));

lemma void cs_to_ccs_drop(int n, list<char> xs);
  requires true;
  ensures cs_to_ccs(drop(n, xs)) == drop(n, cs_to_ccs(xs));

lemma void c_to_cc_inj(char c1, char c2);
  requires true;
  ensures  true == ((c_to_cc(c1) == c_to_cc(c2)) == (c1 == c2));

lemma void cs_to_ccs_inj(list<char> cs1, list<char> cs2);
  requires true;
  ensures  true == ((cs_to_ccs(cs1) == cs_to_ccs(cs2)) == (cs1 == cs2));

lemma void cs_to_ccs_chars(char* b, list<char> cs2);
  requires [?f]chars(b, ?c, ?cs1) &*&
           cs_to_ccs(cs1) == cs_to_ccs(cs2);
  ensures  [f]chars(b, c, cs2);

lemma void cs_to_ccs_crypto_chars(char *array, list<char> cs);
  requires [?f]crypto_chars(?kind, array, ?n, cs_to_ccs(cs)) &*&
           col || kind == normal;
  ensures  [f]chars(array, n, cs);

lemma void cs_to_ccs_length(list<char> cs);
  requires true;
  ensures  length(cs) == length(cs_to_ccs(cs));
