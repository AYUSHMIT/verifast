#ifndef CRYPTOGRAM_LEVELS_GH
#define CRYPTOGRAM_LEVELS_GH

#include "auxiliary_definitions.gh"
#include "cryptogram.gh"

//How deep are cryptograms nested through their payload?
fixpoint nat cg_level(cryptogram cg);

//Upper bound on the nesting of cryptograms.
fixpoint bool cg_level_below(nat bound, cryptogram cg)
{
  return int_of_nat(cg_level(cg)) < int_of_nat(bound);
}

//Maximum upper bound on the nesting of cryptograms.
fixpoint nat cg_level_max();

lemma_auto void cg_level_max_(cryptogram cg);
  requires true;
  ensures  true == cg_level_below(cg_level_max, cg);

// Induction is only allowed for generated or public cryptograms to prevent
// crypto cycles during induction, e.g. E(...E(E(E(m)))) == m. If only
// cryptograms generated in some run are considered, then no cycle
// can occur unless there is a collision.
lemma void cg_level_ind(cryptogram cg, cryptogram cg_pay,
                        list<crypto_char> prefix, list<crypto_char> suffix);
  requires cg_payload(cg) == some(?pay) &*&
           pay == append(prefix, append(ccs_for_cg(cg_pay), suffix));
  ensures  col || true == cg_level_below(cg_level(cg), cg_pay);

#endif
